{"version":3,"sources":["mvc/history/history-model.js"],"names":["_","Backbone","History","Model","extend","_baseMvc2","default","LoggableMixin","mixin","SearchableModelMixin","_logNamespace","UPDATE_DELAY","defaults","model_class","id","name","state","deleted","contents_active","contents_states","urlRoot","Galaxy","root","contentsClass","_historyContents2","HistoryContents","searchAttributes","searchAliases","title","tag","initialize","historyJSON","options","logger","this","log","history","historyId","get","order","_setUpListeners","on","error","model","xhr","msg","details","clearUpdateTimeout","change:id","newId","contents","_setUpCollectionListeners","listenTo","trigger","apply","jQuery","makeArray","arguments","contentsShown","contentsActive","shown","active","includeDeleted","includeHidden","hidden","nice_size","size","_utils2","bytesToString","_localization2","toJSON","prototype","call","key","ownedByCurrUser","user","isAnonymous","numOfUnfinishedJobs","unfinishedJobIds","length","numOfUnfinishedShownContents","runningAndActive","_fetchContentRelatedAttributes","contentRelatedAttrs","fetch","param","keys","join","_this","lastUpdateTime","allFetched","currentPage","fetchPage","fetchUpdated","done","response","status","serverResponseDatetime","Date","getResponseHeader","err","console","checkForUpdates","_this2","delay","refresh","_delayThenUpdate","updateTimeoutId","setTimeout","historyData","clearTimeout","stopPolling","parse","parsed","nonReadyContentCount","create_time","update_time","fetchWithContents","self","view","then","setHistoryId","contentsOptions","fetchContents","fetchCurrentPage","_delete","when","save","purged","copy","current","allDatasets","undefined","Error","postData","history_id","setAsCurrent","getJSON","toString","_collectionSuper","_controlledFetchCollection2","InfinitelyScrollingCollection","HistoryCollection","limitOnFirstFetch","limitPerFetch","models","currentHistoryId","setUpListeners","url","change:deleted","remove","original","newData","setCurrent","oldCurrentId","_buildFetchData","_buildFetchFilters","filters","debug","fetchFirst","_this3","copied","silent","limit","encoded_id-in","fetchMore","comparators","superFilters","ascending","buildComparator","size-asc","sort","currentHistory","create","data","hdas","historyOptions","xhrOptions","collection","offset"],"mappings":"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","file":"../../../scripts/mvc/history/history-model.js","sourcesContent":["import HISTORY_CONTENTS from \"mvc/history/history-contents\";\nimport CONTROLLED_FETCH_COLLECTION from \"mvc/base/controlled-fetch-collection\";\nimport UTILS from \"utils/utils\";\nimport BASE_MVC from \"mvc/base-mvc\";\nimport _l from \"utils/localization\";\nimport * as _ from \"libs/underscore\";\nimport * as Backbone from \"libs/backbone\";\n\n/* global jQuery */\n/* global Galaxy */\n\n//==============================================================================\n/** @class Model for a Galaxy history resource - both a record of user\n *      tool use and a collection of the datasets those tools produced.\n *  @name History\n *  @augments Backbone.Model\n */\nvar History = Backbone.Model.extend(BASE_MVC.LoggableMixin).extend(\n    BASE_MVC.mixin(\n        BASE_MVC.SearchableModelMixin,\n        /** @lends History.prototype */ {\n            _logNamespace: \"history\",\n\n            /** ms between fetches when checking running jobs/datasets for updates */\n            UPDATE_DELAY: 4000,\n\n            // values from api (may need more)\n            defaults: {\n                model_class: \"History\",\n                id: null,\n                name: \"Unnamed History\",\n                state: \"new\",\n\n                deleted: false,\n                contents_active: {},\n                contents_states: {}\n            },\n\n            urlRoot: `${Galaxy.root}api/histories`,\n\n            contentsClass: HISTORY_CONTENTS.HistoryContents,\n\n            /** What model fields to search with */\n            searchAttributes: [\"name\", \"annotation\", \"tags\"],\n\n            /** Adding title and singular tag */\n            searchAliases: {\n                title: \"name\",\n                tag: \"tags\"\n            },\n\n            // ........................................................................ set up/tear down\n            /** Set up the model\n             *  @param {Object} historyJSON model data for this History\n             *  @param {Object} options     any extra settings including logger\n             */\n            initialize: function(historyJSON, options) {\n                options = options || {};\n                this.logger = options.logger || null;\n                this.log(`${this}.initialize:`, historyJSON, options);\n\n                /** HistoryContents collection of the HDAs contained in this history. */\n                this.contents = new this.contentsClass([], {\n                    history: this,\n                    historyId: this.get(\"id\"),\n                    order: options.order\n                });\n\n                this._setUpListeners();\n                this._setUpCollectionListeners();\n\n                /** cached timeout id for the dataset updater */\n                this.updateTimeoutId = null;\n            },\n\n            /** set up any event listeners for this history including those to the contained HDAs\n             *  events: error:contents  if an error occurred with the contents collection\n             */\n            _setUpListeners: function() {\n                // if the model's id changes ('current' or null -> an actual id), update the contents history_id\n                return this.on({\n                    error: function(model, xhr, options, msg, details) {\n                        this.clearUpdateTimeout();\n                    },\n                    \"change:id\": function(model, newId) {\n                        if (this.contents) {\n                            this.contents.historyId = newId;\n                        }\n                    }\n                });\n            },\n\n            /** event handlers for the contents submodels */\n            _setUpCollectionListeners: function() {\n                if (!this.contents) {\n                    return this;\n                }\n                // bubble up errors\n                return this.listenTo(this.contents, {\n                    error: function() {\n                        this.trigger.apply(this, jQuery.makeArray(arguments));\n                    }\n                });\n            },\n\n            // ........................................................................ derived attributes\n            /**  */\n            contentsShown: function() {\n                var contentsActive = this.get(\"contents_active\");\n                var shown = contentsActive.active || 0;\n                shown += this.contents.includeDeleted ? contentsActive.deleted : 0;\n                shown += this.contents.includeHidden ? contentsActive.hidden : 0;\n                return shown;\n            },\n\n            /** convert size in bytes to a more human readable version */\n            nice_size: function() {\n                var size = this.get(\"size\");\n                return size ? UTILS.bytesToString(size, true, 2) : _l(\"(empty)\");\n            },\n\n            /** override to add nice_size */\n            toJSON: function() {\n                return _.extend(Backbone.Model.prototype.toJSON.call(this), {\n                    nice_size: this.nice_size()\n                });\n            },\n\n            /** override to allow getting nice_size */\n            get: function(key) {\n                if (key === \"nice_size\") {\n                    return this.nice_size();\n                }\n                return Backbone.Model.prototype.get.apply(this, arguments);\n            },\n\n            // ........................................................................ common queries\n            /** T/F is this history owned by the current user (Galaxy.user)\n             *      Note: that this will return false for an anon user even if the history is theirs.\n             */\n            ownedByCurrUser: function() {\n                // no currUser\n                if (!Galaxy || !Galaxy.user) {\n                    return false;\n                }\n                // user is anon or history isn't owned\n                if (Galaxy.user.isAnonymous() || Galaxy.user.id !== this.get(\"user_id\")) {\n                    return false;\n                }\n                return true;\n            },\n\n            /** Return the number of running jobs assoc with this history (note: unknown === 0) */\n            numOfUnfinishedJobs: function() {\n                var unfinishedJobIds = this.get(\"non_ready_jobs\");\n                return unfinishedJobIds ? unfinishedJobIds.length : 0;\n            },\n\n            /** Return the number of running hda/hdcas in this history (note: unknown === 0) */\n            numOfUnfinishedShownContents: function() {\n                return this.contents.runningAndActive().length || 0;\n            },\n\n            // ........................................................................ updates\n            _fetchContentRelatedAttributes: function() {\n                var contentRelatedAttrs = [\"size\", \"non_ready_jobs\", \"contents_active\", \"hid_counter\"];\n                return this.fetch({\n                    data: jQuery.param({\n                        keys: contentRelatedAttrs.join(\",\")\n                    })\n                });\n            },\n\n            /** check for any changes since the last time we updated (or fetch all if ) */\n            refresh: function(options) {\n                // console.log( this + '.refresh' );\n                options = options || {};\n\n                // note if there was no previous update time, all summary contents will be fetched\n                var lastUpdateTime = this.lastUpdateTime;\n                // if we don't flip this, then a fully-fetched list will not be re-checked via fetch\n                this.contents.allFetched = false;\n                var fetchFn =\n                    this.contents.currentPage !== 0\n                        ? () => this.contents.fetchPage(this.contents.currentPage)\n                        : () => this.contents.fetchUpdated(lastUpdateTime);\n                // note: if there was no previous update time, all summary contents will be fetched\n                return fetchFn().done((response, status, xhr) => {\n                    var serverResponseDatetime;\n                    try {\n                        serverResponseDatetime = new Date(xhr.getResponseHeader(\"Date\"));\n                    } catch (err) {\n                        console.error(err);\n                    }\n                    this.lastUpdateTime = serverResponseDatetime || new Date();\n                    this.checkForUpdates(options);\n                });\n            },\n\n            /** continuously fetch updated contents every UPDATE_DELAY ms if this history's datasets or jobs are unfinished */\n            checkForUpdates: function(options) {\n                // console.log( this + '.checkForUpdates' );\n                options = options || {};\n                var delay = this.UPDATE_DELAY;\n                if (!this.id) {\n                    return;\n                }\n\n                var _delayThenUpdate = () => {\n                    // prevent buildup of updater timeouts by clearing previous if any, then set new and cache id\n                    this.clearUpdateTimeout();\n                    this.updateTimeoutId = setTimeout(() => {\n                        this.refresh(options);\n                    }, delay);\n                };\n\n                // if there are still datasets in the non-ready state, recurse into this function with the new time\n                var nonReadyContentCount = this.numOfUnfinishedShownContents();\n                // console.log( 'nonReadyContentCount:', nonReadyContentCount );\n                if (nonReadyContentCount > 0) {\n                    _delayThenUpdate();\n                } else {\n                    // no datasets are running, but currently runnning jobs may still produce new datasets\n                    // see if the history has any running jobs and continue to update if so\n                    // (also update the size for the user in either case)\n                    this._fetchContentRelatedAttributes().done(historyData => {\n                        // console.log( 'non_ready_jobs:', historyData.non_ready_jobs );\n                        if (this.numOfUnfinishedJobs() > 0) {\n                            _delayThenUpdate();\n                        } else {\n                            // otherwise, let listeners know that all updates have stopped\n                            this.trigger(\"ready\");\n                        }\n                    });\n                }\n            },\n\n            /** clear the timeout and the cached timeout id */\n            clearUpdateTimeout: function() {\n                if (this.updateTimeoutId) {\n                    clearTimeout(this.updateTimeoutId);\n                    this.updateTimeoutId = null;\n                }\n            },\n\n            stopPolling: function() {\n                this.clearUpdateTimeout();\n                if (this.contents) {\n                    this.contents.stopPolling();\n                }\n            },\n\n            // ........................................................................ ajax\n            /** override to use actual Dates objects for create/update times */\n            parse: function(response, options) {\n                var parsed = Backbone.Model.prototype.parse.call(this, response, options);\n                if (parsed.create_time) {\n                    parsed.create_time = new Date(parsed.create_time);\n                }\n                if (parsed.update_time) {\n                    parsed.update_time = new Date(parsed.update_time);\n                }\n                return parsed;\n            },\n\n            /** fetch this histories data (using options) then it's contents (using contentsOptions) */\n            fetchWithContents: function(options, contentsOptions) {\n                options = options || {};\n                var self = this;\n\n                // console.log( this + '.fetchWithContents' );\n                // TODO: push down to a base class\n                options.view = \"dev-detailed\";\n\n                // fetch history then use history data to fetch (paginated) contents\n                return this.fetch(options).then(function getContents(history) {\n                    self.contents.history = self;\n                    self.contents.setHistoryId(history.id);\n                    return self.fetchContents(contentsOptions);\n                });\n            },\n\n            /** fetch this histories contents, adjusting options based on the stored history preferences */\n            fetchContents: function(options) {\n                options = options || {};\n\n                // we're updating, reset the update time\n                this.lastUpdateTime = new Date();\n                return this.contents.fetchCurrentPage(options);\n            },\n\n            /** save this history, _Mark_ing it as deleted (just a flag) */\n            _delete: function(options) {\n                if (this.get(\"deleted\")) {\n                    return jQuery.when();\n                }\n                return this.save({ deleted: true }, options);\n            },\n            /** purge this history, _Mark_ing it as purged and removing all dataset data from the server */\n            purge: function(options) {\n                if (this.get(\"purged\")) {\n                    return jQuery.when();\n                }\n                return this.save({ deleted: true, purged: true }, options);\n            },\n            /** save this history, _Mark_ing it as undeleted */\n            undelete: function(options) {\n                if (!this.get(\"deleted\")) {\n                    return jQuery.when();\n                }\n                return this.save({ deleted: false }, options);\n            },\n\n            /** Make a copy of this history on the server\n             *  @param {Boolean} current    if true, set the copy as the new current history (default: true)\n             *  @param {String} name        name of new history (default: none - server sets to: Copy of <current name>)\n             *  @fires copied               passed this history and the response JSON from the copy\n             *  @returns {xhr}\n             */\n            copy: function(current, name, allDatasets) {\n                current = current !== undefined ? current : true;\n                if (!this.id) {\n                    throw new Error(\"You must set the history ID before copying it.\");\n                }\n\n                var postData = { history_id: this.id };\n                if (current) {\n                    postData.current = true;\n                }\n                if (name) {\n                    postData.name = name;\n                }\n                if (!allDatasets) {\n                    postData.all_datasets = false;\n                }\n                postData.view = \"dev-detailed\";\n\n                var history = this;\n                var copy = jQuery.post(this.urlRoot, postData);\n                // if current - queue to setAsCurrent before firing 'copied'\n                if (current) {\n                    return copy.then(response => {\n                        var newHistory = new History(response);\n                        return newHistory.setAsCurrent().done(() => {\n                            history.trigger(\"copied\", history, response);\n                        });\n                    });\n                }\n                return copy.done(response => {\n                    history.trigger(\"copied\", history, response);\n                });\n            },\n\n            setAsCurrent: function() {\n                var history = this;\n\n                var xhr = jQuery.getJSON(`${Galaxy.root}history/set_as_current?id=${this.id}`);\n\n                xhr.done(() => {\n                    history.trigger(\"set-as-current\", history);\n                });\n                return xhr;\n            },\n\n            // ........................................................................ misc\n            toString: function() {\n                return `History(${this.get(\"id\")},${this.get(\"name\")})`;\n            }\n        }\n    )\n);\n\n//==============================================================================\nvar _collectionSuper = CONTROLLED_FETCH_COLLECTION.InfinitelyScrollingCollection;\n/** @class A collection of histories (per user)\n *      that maintains the current history as the first in the collection.\n *  New or copied histories become the current history.\n */\nvar HistoryCollection = _collectionSuper.extend(BASE_MVC.LoggableMixin).extend({\n    _logNamespace: \"history\",\n\n    model: History,\n    /** @type {String} initial order used by collection */\n    order: \"update_time\",\n    /** @type {Number} limit used for the first fetch (or a reset) */\n    limitOnFirstFetch: 10,\n    /** @type {Number} limit used for each subsequent fetch */\n    limitPerFetch: 10,\n\n    initialize: function(models, options) {\n        options = options || {};\n        this.log(\"HistoryCollection.initialize\", models, options);\n        _collectionSuper.prototype.initialize.call(this, models, options);\n\n        /** @type {boolean} should deleted histories be included */\n        this.includeDeleted = options.includeDeleted || false;\n\n        /** @type {String} encoded id of the history that's current */\n        this.currentHistoryId = options.currentHistoryId;\n\n        this.setUpListeners();\n        // note: models are sent to reset *after* this fn ends; up to this point\n        // the collection *is empty*\n    },\n\n    urlRoot: `${Galaxy.root}api/histories`,\n    url: function() {\n        return this.urlRoot;\n    },\n\n    /** set up reflexive event handlers */\n    setUpListeners: function setUpListeners() {\n        return this.on({\n            // when a history is deleted, remove it from the collection (if optionally set to do so)\n            \"change:deleted\": function(history) {\n                // TODO: this becomes complicated when more filters are used\n                this.debug(\"change:deleted\", this.includeDeleted, history.get(\"deleted\"));\n                if (!this.includeDeleted && history.get(\"deleted\")) {\n                    this.remove(history);\n                }\n            },\n            // listen for a history copy, setting it to current\n            copied: function(original, newData) {\n                this.setCurrent(new History(newData, []));\n            },\n            // when a history is made current, track the id in the collection\n            \"set-as-current\": function(history) {\n                var oldCurrentId = this.currentHistoryId;\n                this.trigger(\"no-longer-current\", oldCurrentId);\n                this.currentHistoryId = history.id;\n            }\n        });\n    },\n\n    /** override to change view */\n    _buildFetchData: function(options) {\n        return _.extend(_collectionSuper.prototype._buildFetchData.call(this, options), {\n            view: \"dev-detailed\"\n        });\n    },\n\n    /** override to filter out deleted and purged */\n    _buildFetchFilters: function(options) {\n        var superFilters = _collectionSuper.prototype._buildFetchFilters.call(this, options) || {};\n        var filters = {};\n        if (this.includeDeleted !== true) {\n            filters.deleted = false;\n            filters.purged = false;\n        } else {\n            // force API to return both deleted and non\n            //TODO: when the API is updated, remove this\n            filters.deleted = null;\n        }\n        return _.defaults(superFilters, filters);\n    },\n\n    /** override to fetch current as well (as it may be outside the first 10, etc.) */\n    fetchFirst: function(options) {\n        // TODO: batch?\n        var xhr = jQuery.when();\n        if (this.currentHistoryId) {\n            xhr = _collectionSuper.prototype.fetchFirst.call(this, {\n                silent: true,\n                limit: 1,\n                filters: {\n                    \"encoded_id-in\": this.currentHistoryId,\n                    // without these a deleted current history will return [] here and block the other xhr\n                    deleted: null,\n                    purged: \"\"\n                }\n            });\n        }\n        return xhr.then(() => {\n            options = options || {};\n            options.offset = 0;\n            return this.fetchMore(options);\n        });\n    },\n\n    /** @type {Object} map of collection available sorting orders containing comparator fns */\n    comparators: _.extend(_.clone(_collectionSuper.prototype.comparators), {\n        name: BASE_MVC.buildComparator(\"name\", {\n            ascending: true\n        }),\n        \"name-dsc\": BASE_MVC.buildComparator(\"name\", {\n            ascending: false\n        }),\n        size: BASE_MVC.buildComparator(\"size\", {\n            ascending: false\n        }),\n        \"size-asc\": BASE_MVC.buildComparator(\"size\", {\n            ascending: true\n        })\n    }),\n\n    /** override to always have the current history first */\n    sort: function(options) {\n        options = options || {};\n        var silent = options.silent;\n        var currentHistory = this.remove(this.get(this.currentHistoryId));\n        _collectionSuper.prototype.sort.call(this, _.defaults({ silent: true }, options));\n        this.unshift(currentHistory, { silent: true });\n        if (!silent) {\n            this.trigger(\"sort\", this, options);\n        }\n        return this;\n    },\n\n    /** create a new history and by default set it to be the current history */\n    create: function create(data, hdas, historyOptions, xhrOptions) {\n        //TODO: .create is actually a collection function that's overridden here\n        var collection = this;\n\n        var xhr = jQuery.getJSON(`${Galaxy.root}history/create_new_current`);\n        return xhr.done(newData => {\n            collection.setCurrent(new History(newData, [], historyOptions || {}));\n        });\n    },\n\n    /** set the current history to the given history, placing it first in the collection.\n     *  Pass standard bbone options for use in unshift.\n     *  @triggers new-current passed history and this collection\n     */\n    setCurrent: function(history, options) {\n        options = options || {};\n        // new histories go in the front\n        this.unshift(history, options);\n        this.currentHistoryId = history.get(\"id\");\n        if (!options.silent) {\n            this.trigger(\"new-current\", history, this);\n        }\n        return this;\n    },\n\n    toString: function toString() {\n        return `HistoryCollection(${this.length},current:${this.currentHistoryId})`;\n    }\n});\n\n//==============================================================================\nexport default {\n    History: History,\n    HistoryCollection: HistoryCollection\n};\n"]}