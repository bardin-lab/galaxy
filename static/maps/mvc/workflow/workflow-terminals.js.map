{"version":3,"sources":["mvc/workflow/workflow-terminals.js"],"names":["CollectionTypeDescription","collectionType","this","isCollection","rank","split","length","window","workflow_globals","NULL_COLLECTION_TYPE_DESCRIPTION","canMatch","canMapOver","otherCollectionType","toString","other","ANY_COLLECTION_TYPE_DESCRIPTION","equal","$","extend","prototype","otherCollectionTypeDescription","requiredSuffix","_endsWith","effectiveMapOver","substring","effectiveCollectionType","str","suffix","indexOf","TerminalMapping","Backbone","Model","initialize","attr","mapOver","terminalMapping","disableMapOver","terminal","setMapOver","collectionTypeDescription","trigger","Terminal","element","connect","connectors","connector","node","markChanged","disconnect","splice","inArray","redraw","each","_","c","slice","destroy","destroyInvalidConnections","val","multiple","output_terminals","outputTerminal","isMappedOver","resetMappingIfNeeded","call","OutputTerminal","hasConnectedMappedInputTerminals","mappedInputTerminals","mappedInput","hasMappedOverInputTerminals","resetMapping","handle2","connectedInput","destroyIfInvalid","BaseInputTerminal","update","_inputFilled","hasConnectedOutputTerminals","connected","inputFilled","_collectionAttached","firstOutput","handle1","_mappingConstraints","constraints","push","first","values","inputTerminal","_producesAcceptableDatatype","t","thisDatatype","datatypes","cat_outputs","post_job_actions","pja_i","pja","action_type","output_name","name","action_arguments","other_datatype_i","newtype","other_datatype","_otherCollectionType","app","isSubType","InputTerminal","otherMapOver","input","append","collection","attachable","other_output","thisMapOver","every","bind","InputCollectionTerminal","collectionTypes","extensions","_effectiveMapOver","some","collectionTypeIndex","_effectiveCollectionTypes","effectiveCollectionTypes","map","mappingConstraints","OutputCollectionTerminal","collection_type","collectionTypeSource","console","output","newCollectionType","log"],"mappings":"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","file":"../../../scripts/mvc/workflow/workflow-terminals.js","sourcesContent":["// TODO; tie into Galaxy state?\nwindow.workflow_globals = window.workflow_globals || {};\nfunction CollectionTypeDescription(collectionType) {\n    this.collectionType = collectionType;\n    this.isCollection = true;\n    this.rank = collectionType.split(\":\").length;\n}\n\nvar NULL_COLLECTION_TYPE_DESCRIPTION = {\n    isCollection: false,\n    canMatch: function() {\n        return false;\n    },\n    canMapOver: function() {\n        return false;\n    },\n    toString: function() {\n        return \"NullCollectionType[]\";\n    },\n    append: function(otherCollectionType) {\n        return otherCollectionType;\n    },\n    equal: function(other) {\n        return other === this;\n    }\n};\n\nvar ANY_COLLECTION_TYPE_DESCRIPTION = {\n    isCollection: true,\n    canMatch: function(other) {\n        return NULL_COLLECTION_TYPE_DESCRIPTION !== other;\n    },\n    canMapOver: function() {\n        return false;\n    },\n    toString: function() {\n        return \"AnyCollectionType[]\";\n    },\n    append: function() {\n        throw \"Cannot append to ANY_COLLECTION_TYPE_DESCRIPTION\";\n    },\n    equal: function(other) {\n        return other === this;\n    }\n};\n\n$.extend(CollectionTypeDescription.prototype, {\n    append: function(otherCollectionTypeDescription) {\n        if (otherCollectionTypeDescription === NULL_COLLECTION_TYPE_DESCRIPTION) {\n            return this;\n        }\n        if (otherCollectionTypeDescription === ANY_COLLECTION_TYPE_DESCRIPTION) {\n            return otherCollectionTypeDescription;\n        }\n        return new CollectionTypeDescription(`${this.collectionType}:${otherCollectionTypeDescription.collectionType}`);\n    },\n    canMatch: function(otherCollectionTypeDescription) {\n        if (otherCollectionTypeDescription === NULL_COLLECTION_TYPE_DESCRIPTION) {\n            return false;\n        }\n        if (otherCollectionTypeDescription === ANY_COLLECTION_TYPE_DESCRIPTION) {\n            return true;\n        }\n        return otherCollectionTypeDescription.collectionType == this.collectionType;\n    },\n    canMapOver: function(otherCollectionTypeDescription) {\n        if (otherCollectionTypeDescription === NULL_COLLECTION_TYPE_DESCRIPTION) {\n            return false;\n        }\n        if (otherCollectionTypeDescription === ANY_COLLECTION_TYPE_DESCRIPTION) {\n            return false;\n        }\n        if (this.rank <= otherCollectionTypeDescription.rank) {\n            // Cannot map over self...\n            return false;\n        }\n        var requiredSuffix = otherCollectionTypeDescription.collectionType;\n        return this._endsWith(this.collectionType, requiredSuffix);\n    },\n    effectiveMapOver: function(otherCollectionTypeDescription) {\n        var otherCollectionType = otherCollectionTypeDescription.collectionType;\n        var effectiveCollectionType = this.collectionType.substring(\n            0,\n            this.collectionType.length - otherCollectionType.length - 1\n        );\n        return new CollectionTypeDescription(effectiveCollectionType);\n    },\n    equal: function(otherCollectionTypeDescription) {\n        return otherCollectionTypeDescription.collectionType == this.collectionType;\n    },\n    toString: function() {\n        return `CollectionType[${this.collectionType}]`;\n    },\n    _endsWith: function(str, suffix) {\n        return str.indexOf(suffix, str.length - suffix.length) !== -1;\n    }\n});\n\nvar TerminalMapping = Backbone.Model.extend({\n    initialize: function(attr) {\n        this.mapOver = attr.mapOver || NULL_COLLECTION_TYPE_DESCRIPTION;\n        this.terminal = attr.terminal;\n        this.terminal.terminalMapping = this;\n    },\n    disableMapOver: function() {\n        this.setMapOver(NULL_COLLECTION_TYPE_DESCRIPTION);\n    },\n    setMapOver: function(collectionTypeDescription) {\n        // TODO: Can I use \"attributes\" or something to auto trigger \"change\"\n        // event?\n        this.mapOver = collectionTypeDescription;\n        this.trigger(\"change\");\n    }\n});\n\nvar Terminal = Backbone.Model.extend({\n    initialize: function(attr) {\n        this.element = attr.element;\n        this.connectors = [];\n    },\n    connect: function(connector) {\n        this.connectors.push(connector);\n        if (this.node) {\n            this.node.markChanged();\n        }\n    },\n    disconnect: function(connector) {\n        this.connectors.splice($.inArray(connector, this.connectors), 1);\n        if (this.node) {\n            this.node.markChanged();\n            this.resetMappingIfNeeded();\n        }\n    },\n    redraw: function() {\n        $.each(this.connectors, (_, c) => {\n            c.redraw();\n        });\n    },\n    destroy: function() {\n        $.each(this.connectors.slice(), (_, c) => {\n            c.destroy();\n        });\n    },\n    destroyInvalidConnections: function() {\n        _.each(this.connectors, connector => {\n            if (connector) {\n                connector.destroyIfInvalid();\n            }\n        });\n    },\n    setMapOver: function(val) {\n        if (this.multiple) {\n            return; // Cannot set this to be multirun...\n        }\n\n        if (!this.mapOver().equal(val)) {\n            this.terminalMapping.setMapOver(val);\n            _.each(this.node.output_terminals, outputTerminal => {\n                outputTerminal.setMapOver(val);\n            });\n        }\n    },\n    mapOver: function() {\n        if (!this.terminalMapping) {\n            return NULL_COLLECTION_TYPE_DESCRIPTION;\n        } else {\n            return this.terminalMapping.mapOver;\n        }\n    },\n    isMappedOver: function() {\n        return this.terminalMapping && this.terminalMapping.mapOver.isCollection;\n    },\n    resetMapping: function() {\n        this.terminalMapping.disableMapOver();\n    },\n\n    resetMappingIfNeeded: function() {} // Subclasses should override this...\n});\n\nvar OutputTerminal = Terminal.extend({\n    initialize: function(attr) {\n        Terminal.prototype.initialize.call(this, attr);\n        this.datatypes = attr.datatypes;\n    },\n\n    resetMappingIfNeeded: function() {\n        // If inputs were only mapped over to preserve\n        // an output just disconnected reset these...\n        if (!this.node.hasConnectedOutputTerminals() && !this.node.hasConnectedMappedInputTerminals()) {\n            _.each(this.node.mappedInputTerminals(), mappedInput => {\n                mappedInput.resetMappingIfNeeded();\n            });\n        }\n\n        var noMappedInputs = !this.node.hasMappedOverInputTerminals();\n        if (noMappedInputs) {\n            this.resetMapping();\n        }\n    },\n\n    resetMapping: function() {\n        this.terminalMapping.disableMapOver();\n        _.each(this.connectors, connector => {\n            var connectedInput = connector.handle2;\n            if (connectedInput) {\n                // Not exactly right because this is still connected.\n                // Either rewrite resetMappingIfNeeded or disconnect\n                // and reconnect if valid.\n                connectedInput.resetMappingIfNeeded();\n                connector.destroyIfInvalid();\n            }\n        });\n    }\n});\n\nvar BaseInputTerminal = Terminal.extend({\n    initialize: function(attr) {\n        Terminal.prototype.initialize.call(this, attr);\n        this.update(attr.input); // subclasses should implement this...\n    },\n    canAccept: function(other) {\n        if (this._inputFilled()) {\n            return false;\n        } else {\n            return this.attachable(other);\n        }\n    },\n    resetMappingIfNeeded: function() {\n        var mapOver = this.mapOver();\n        if (!mapOver.isCollection) {\n            return;\n        }\n        // No output terminals are counting on this being mapped\n        // over if connected inputs are still mapped over or if none\n        // of the outputs are connected...\n        var reset = this.node.hasConnectedMappedInputTerminals() || !this.node.hasConnectedOutputTerminals();\n        if (reset) {\n            this.resetMapping();\n        }\n    },\n    resetMapping: function() {\n        this.terminalMapping.disableMapOver();\n        if (!this.node.hasMappedOverInputTerminals()) {\n            _.each(this.node.output_terminals, terminal => {\n                // This shouldn't be called if there are mapped over\n                // outputs.\n                terminal.resetMapping();\n            });\n        }\n    },\n    connected: function() {\n        return this.connectors.length !== 0;\n    },\n    _inputFilled: function() {\n        var inputFilled;\n        if (!this.connected()) {\n            inputFilled = false;\n        } else {\n            if (this.multiple) {\n                if (this._collectionAttached()) {\n                    // Can only attach one collection to multiple input\n                    // data parameter.\n                    inputFilled = true;\n                } else {\n                    inputFilled = false;\n                }\n            } else {\n                inputFilled = true;\n            }\n        }\n        return inputFilled;\n    },\n    _collectionAttached: function() {\n        if (!this.connected()) {\n            return false;\n        } else {\n            var firstOutput = this.connectors[0].handle1;\n            if (!firstOutput) {\n                return false;\n            } else {\n                if (\n                    firstOutput.isCollection ||\n                    firstOutput.isMappedOver() ||\n                    firstOutput.datatypes.indexOf(\"input_collection\") > 0\n                ) {\n                    return true;\n                } else {\n                    return false;\n                }\n            }\n        }\n    },\n    _mappingConstraints: function() {\n        // If this is a connected terminal, return list of collection types\n        // other terminals connected to node are constraining mapping to.\n        if (!this.node) {\n            return []; // No node - completely unconstrained\n        }\n        var mapOver = this.mapOver();\n        if (mapOver.isCollection) {\n            return [mapOver];\n        }\n\n        var constraints = [];\n        if (!this.node.hasConnectedOutputTerminals()) {\n            _.each(this.node.connectedMappedInputTerminals(), inputTerminal => {\n                constraints.push(inputTerminal.mapOver());\n            });\n        } else {\n            // All outputs should have same mapOver status - least specific.\n            constraints.push(_.first(_.values(this.node.output_terminals)).mapOver());\n        }\n        return constraints;\n    },\n    _producesAcceptableDatatype: function(other) {\n        // other is a non-collection output...\n        for (var t in this.datatypes) {\n            var thisDatatype = this.datatypes[t];\n            if (thisDatatype == \"input\") {\n                return true;\n            }\n            var cat_outputs = [];\n            cat_outputs = cat_outputs.concat(other.datatypes);\n            if (other.node.post_job_actions) {\n                for (var pja_i in other.node.post_job_actions) {\n                    var pja = other.node.post_job_actions[pja_i];\n                    if (\n                        pja.action_type == \"ChangeDatatypeAction\" &&\n                        (pja.output_name === \"\" || pja.output_name == other.name) &&\n                        pja.action_arguments\n                    ) {\n                        cat_outputs.push(pja.action_arguments.newtype);\n                    }\n                }\n            }\n            // FIXME: No idea what to do about case when datatype is 'input'\n            for (var other_datatype_i in cat_outputs) {\n                var other_datatype = cat_outputs[other_datatype_i];\n                if (\n                    other_datatype == \"input\" ||\n                    other_datatype == \"_sniff_\" ||\n                    other_datatype == \"input_collection\" ||\n                    window.workflow_globals.app.isSubType(cat_outputs[other_datatype_i], thisDatatype)\n                ) {\n                    return true;\n                }\n            }\n        }\n        return false;\n    },\n    _otherCollectionType: function(other) {\n        var otherCollectionType = NULL_COLLECTION_TYPE_DESCRIPTION;\n        if (other.isCollection) {\n            otherCollectionType = other.collectionType;\n        }\n        var otherMapOver = other.mapOver();\n        if (otherMapOver.isCollection) {\n            otherCollectionType = otherMapOver.append(otherCollectionType);\n        }\n        return otherCollectionType;\n    }\n});\n\nvar InputTerminal = BaseInputTerminal.extend({\n    update: function(input) {\n        this.datatypes = input.extensions;\n        this.multiple = input.multiple;\n        this.collection = false;\n    },\n    connect: function(connector) {\n        BaseInputTerminal.prototype.connect.call(this, connector);\n        var other_output = connector.handle1;\n        if (!other_output) {\n            return;\n        }\n        var otherCollectionType = this._otherCollectionType(other_output);\n        if (otherCollectionType.isCollection) {\n            this.setMapOver(otherCollectionType);\n        }\n    },\n    attachable: function(other) {\n        var otherCollectionType = this._otherCollectionType(other);\n        var thisMapOver = this.mapOver();\n        if (otherCollectionType.isCollection) {\n            if (this.multiple) {\n                if (this.connected() && !this._collectionAttached()) {\n                    // if single inputs attached, cannot also attach a\n                    // collection (yet...)\n                    return false;\n                }\n                if (otherCollectionType.rank == 1) {\n                    return this._producesAcceptableDatatype(other);\n                } else {\n                    // TODO: Allow subcollection mapping over this as if it were\n                    // a list collection input.\n                    return false;\n                }\n            }\n            if (thisMapOver.isCollection && thisMapOver.canMatch(otherCollectionType)) {\n                return this._producesAcceptableDatatype(other);\n            } else {\n                //  Need to check if this would break constraints...\n                var mappingConstraints = this._mappingConstraints();\n                if (mappingConstraints.every(_.bind(otherCollectionType.canMatch, otherCollectionType))) {\n                    return this._producesAcceptableDatatype(other);\n                } else {\n                    return false;\n                }\n            }\n        } else if (thisMapOver.isCollection) {\n            // Attempting to match a non-collection output to an\n            // explicitly collection input.\n            return false;\n        }\n        return this._producesAcceptableDatatype(other);\n    }\n});\n\nvar InputCollectionTerminal = BaseInputTerminal.extend({\n    update: function(input) {\n        this.multiple = false;\n        this.collection = true;\n        this.datatypes = input.extensions;\n        var collectionTypes = [];\n        if (input.collection_types) {\n            _.each(input.collection_types, collectionType => {\n                collectionTypes.push(new CollectionTypeDescription(collectionType));\n            });\n        } else {\n            collectionTypes.push(ANY_COLLECTION_TYPE_DESCRIPTION);\n        }\n        this.collectionTypes = collectionTypes;\n    },\n    connect: function(connector) {\n        BaseInputTerminal.prototype.connect.call(this, connector);\n        var other = connector.handle1;\n        if (!other) {\n            return;\n        }\n\n        var effectiveMapOver = this._effectiveMapOver(other);\n        this.setMapOver(effectiveMapOver);\n    },\n    _effectiveMapOver: function(other) {\n        var collectionTypes = this.collectionTypes;\n        var otherCollectionType = this._otherCollectionType(other);\n        var canMatch = _.some(collectionTypes, collectionType => collectionType.canMatch(otherCollectionType));\n\n        if (!canMatch) {\n            for (var collectionTypeIndex in collectionTypes) {\n                var collectionType = collectionTypes[collectionTypeIndex];\n                if (otherCollectionType.canMapOver(collectionType)) {\n                    var effectiveMapOver = otherCollectionType.effectiveMapOver(collectionType);\n                    if (effectiveMapOver != NULL_COLLECTION_TYPE_DESCRIPTION) {\n                        return effectiveMapOver;\n                    }\n                }\n            }\n        }\n        return NULL_COLLECTION_TYPE_DESCRIPTION;\n    },\n    _effectiveCollectionTypes: function() {\n        var thisMapOver = this.mapOver();\n        return _.map(this.collectionTypes, t => thisMapOver.append(t));\n    },\n    attachable: function(other) {\n        var otherCollectionType = this._otherCollectionType(other);\n        if (otherCollectionType.isCollection) {\n            var effectiveCollectionTypes = this._effectiveCollectionTypes();\n            var thisMapOver = this.mapOver();\n            var canMatch = _.some(effectiveCollectionTypes, effectiveCollectionType =>\n                effectiveCollectionType.canMatch(otherCollectionType)\n            );\n            if (canMatch) {\n                // Only way a direct match...\n                return this._producesAcceptableDatatype(other);\n                // Otherwise we need to mapOver\n            } else if (thisMapOver.isCollection) {\n                // In this case, mapOver already set and we didn't match skipping...\n                return false;\n            } else if (_.some(this.collectionTypes, collectionType => otherCollectionType.canMapOver(collectionType))) {\n                var effectiveMapOver = this._effectiveMapOver(other);\n                if (!effectiveMapOver.isCollection) {\n                    return false;\n                }\n                //  Need to check if this would break constraints...\n                var mappingConstraints = this._mappingConstraints();\n                if (mappingConstraints.every(effectiveMapOver.canMatch)) {\n                    return this._producesAcceptableDatatype(other);\n                }\n            }\n        }\n        return false;\n    }\n});\n\nvar OutputCollectionTerminal = Terminal.extend({\n    initialize: function(attr) {\n        Terminal.prototype.initialize.call(this, attr);\n        this.datatypes = attr.datatypes;\n        if (attr.collection_type) {\n            this.collectionType = new CollectionTypeDescription(attr.collection_type);\n        } else {\n            var collectionTypeSource = attr.collection_type_source;\n            if (!collectionTypeSource) {\n                console.log(\"Warning: No collection type or collection type source defined.\");\n            }\n            this.collectionType = ANY_COLLECTION_TYPE_DESCRIPTION;\n        }\n        this.isCollection = true;\n    },\n    update: function(output) {\n        var newCollectionType;\n        if (output.collection_type) {\n            newCollectionType = new CollectionTypeDescription(output.collection_type);\n        } else {\n            var collectionTypeSource = output.collection_type_source;\n            if (!collectionTypeSource) {\n                console.log(\"Warning: No collection type or collection type source defined.\");\n            }\n            newCollectionType = ANY_COLLECTION_TYPE_DESCRIPTION;\n        }\n\n        if (newCollectionType.collectionType != this.collectionType.collectionType) {\n            _.each(this.connectors, connector => {\n                // TODO: consider checking if connection valid before removing...\n                connector.destroy();\n            });\n        }\n        this.collectionType = newCollectionType;\n    }\n});\n\nexport default {\n    InputTerminal: InputTerminal,\n    OutputTerminal: OutputTerminal,\n    InputCollectionTerminal: InputCollectionTerminal,\n    OutputCollectionTerminal: OutputCollectionTerminal,\n    TerminalMapping: TerminalMapping,\n\n    // test export\n    CollectionTypeDescription: CollectionTypeDescription,\n    NULL_COLLECTION_TYPE_DESCRIPTION: NULL_COLLECTION_TYPE_DESCRIPTION,\n    ANY_COLLECTION_TYPE_DESCRIPTION: ANY_COLLECTION_TYPE_DESCRIPTION\n};\n"]}