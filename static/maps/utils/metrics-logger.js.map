{"version":3,"sources":["utils/metrics-logger.js"],"names":["MetricsLogger","options","self","this","userId","window","bootstrapped","user","id","consoleLogger","_init","usefulToString","arg","asStr","String","JSON","stringify","LoggingCache","ALL","INFO","WARN","METRIC","NONE","defaultNamespace","consoleFlattenMessages","clientPrefix","consoleLevel","addTime","consoleNamespaceWhitelist","postUrl","delayPostInMs","getPingData","undefined","onServerResponse","prototype","defaultOptions","hasOwnProperty","k","_parseLevel","_postSize","_initCache","cache","maxCacheSize","key","cacheKeyPrefix","err","logLevel","type","level","_typeof","maxSize","upper","toUpperCase","_emitToConsole","Error","emit","namespace","logArguments","_addToCache","arguments","add","_buildEntry","entry","args","Date","_postCache","_sending","postSize","jQuery","when","entries","get","entriesLength","length","postData","metrics","always","message","xhr","readyState","status","responseJSON","responseText","response","remove","_waiting","whitelist","indexOf","Array","slice","call","unshift","info","apply","warn","error","DEBUG","debug","log","ERROR","metric","_hasStorage","_initStorage","localStorage","test","setItem","removeItem","e","getItem","empty","_cache","splice","overage","push","_unparseAndStore","_fetchAndParse","count","removed","print"],"mappings":"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","file":"../../scripts/utils/metrics-logger.js","sourcesContent":["/*global window, jQuery, console */\n/*=============================================================================\nTODO:\n    while anon: logs saved to 'logs-null' - this will never post\n        unless we manually do so at/after login\n        OR prepend when userId and localStorage has 'logs-null'\n    wire up _delayPost and test\n\n=============================================================================*/\n/** @class MetricsLogger\n *\n *  Object to cache, output, and post log/metric messages to the server.\n *  Meant to be attached to the Galaxy object.\n *\n *  Log from objects by either attaching logger directly:\n *      panel.logger.metric( 'user dataset deletion', panel.user.id, hda.toJSON() )\n *  or using the LoggableMixin or addLogging function:\n *      MyBackboneModel.extend( LoggableMixin ).extend({ ... })\n *      addLogging( MyBackboneModel, 'my-backbone-model' )\n *\n *  Log from templates by calling directly from Galaxy object:\n *      Galaxy.logger.metric( 'template loaded', { ownedByUser : true });\n *\n *  If you attempt to log an un-serializable object (circular reference, window, etc.),\n *  that entry will not be cached (or sent). If you set consoleLevel and consoleLogger\n *  appropriately, a warning will be shown when this happens:\n *      > panel.metric( 'something weird with window', { window : window })\n *      !'Metrics logger could not stringify logArguments: ...'\n */\nfunction MetricsLogger(options) {\n    options = options || {};\n    var self = this;\n\n    ///** get the current user's id from bootstrapped data or options */\n    self.userId = window.bootstrapped && window.bootstrapped.user ? window.bootstrapped.user.id : null;\n    self.userId = self.userId || options.userId || null;\n\n    /** the (optional) console to emit logs to */\n    self.consoleLogger = options.consoleLogger || null;\n\n    self._init(options);\n    return self;\n}\n\n//----------------------------------------------------------------------------- defaults and constants\n// see: python std lib, logging\nMetricsLogger.ALL = 0;\nMetricsLogger.LOG = 0;\nMetricsLogger.DEBUG = 10;\nMetricsLogger.INFO = 20;\nMetricsLogger.WARN = 30;\nMetricsLogger.ERROR = 40;\n// metrics levels here?\n//MetricsLogger.MinorEvent  = 45;\n//MetricsLogger.MajorEvent  = 50;\nMetricsLogger.METRIC = 50;\nMetricsLogger.NONE = 100;\n\n/** default options - override these through the constructor */\nMetricsLogger.defaultOptions = {\n    /** if an incoming message has a level >= this, it will be cached - can also be a string (e.g. 'debug') */\n    logLevel: MetricsLogger.NONE,\n    /** if an incoming message has a level >= this, it will be output to the console */\n    consoleLevel: MetricsLogger.NONE,\n    /** the default 'namespace' or label associated with an incoming message (if none is passed) */\n    defaultNamespace: \"Galaxy\",\n    /** the namespaces output to the console (all namespaces will be output if this is falsy)\n     *  note: applies only to the console (not the event/metrics log/cache)\n     */\n    consoleNamespaceWhitelist: null,\n    /** Force all messages into simple strings. */\n    consoleFlattenMessages: false,\n    /** the prefix attached to client-side logs to distinguish them in the metrics db */\n    clientPrefix: \"client.\",\n\n    /** the maximum number of messages the cache should hold; if exceeded older messages are removed first */\n    maxCacheSize: 3000,\n    /** the number of messages accumulate before posting to the server; should be <= maxCacheSize */\n    postSize: 1000,\n    /** T/F whether to add a timestamp to incoming cached messages */\n    addTime: true,\n    /** string to prefix to userid for cache web storage */\n    cacheKeyPrefix: \"logs-\",\n\n    /** the relative url to post messages to */\n    postUrl: \"/api/metrics\",\n    /** delay before trying post again after two failures */\n    delayPostInMs: 1000 * 60 * 10,\n\n    /** an (optional) function that should return an object; used to send additional data with the metrics */\n    getPingData: undefined,\n    /** an (optional) function that will handle the servers response after successfully posting messages */\n    onServerResponse: undefined\n};\n\n//----------------------------------------------------------------------------- set up\n/** initialize the logger with options, set up instance vars and cache, and add onpageunload to window */\nMetricsLogger.prototype._init = function _init(options) {\n    var self = this;\n    self.options = {};\n    for (var k in MetricsLogger.defaultOptions) {\n        if (MetricsLogger.defaultOptions.hasOwnProperty(k)) {\n            self.options[k] = options.hasOwnProperty(k) ? options[k] : MetricsLogger.defaultOptions[k];\n        }\n    }\n    self.options.logLevel = self._parseLevel(self.options.logLevel);\n    self.options.consoleLevel = self._parseLevel(self.options.consoleLevel);\n    //self._emitToConsole( 'debug', 'MetricsLogger', 'MetricsLogger.options:', self.options );\n\n    /** is the logger currently sending? */\n    self._sending = false;\n    /** the setTimeout id if the logger POST has failed more than once */\n    self._waiting = null;\n    /** the current number of entries to send in a POST */\n    self._postSize = self.options.postSize;\n\n    self._initCache();\n\n    return self;\n};\n\n/** initialize the cache */\nMetricsLogger.prototype._initCache = function _initCache() {\n    try {\n        this.cache = new LoggingCache({\n            maxSize: this.options.maxCacheSize,\n            key: this.options.cacheKeyPrefix + this.userId\n        });\n    } catch (err) {\n        this._emitToConsole(\"warn\", \"MetricsLogger\", [\"Could not intitialize logging cache:\", err]);\n        this.options.logLevel = MetricsLogger.NONE;\n    }\n};\n\n/** return the numeric log level if level in 'none, debug, log, info, warn, error' */\nMetricsLogger.prototype._parseLevel = function _parseLevel(level) {\n    var type = typeof level;\n    if (type === \"number\") {\n        return level;\n    }\n    if (type === \"string\") {\n        var upper = level.toUpperCase();\n        if (MetricsLogger.hasOwnProperty(upper)) {\n            return MetricsLogger[upper];\n        }\n    }\n    throw new Error(`Unknown log level: ${level}`);\n};\n\n//----------------------------------------------------------------------------- main entry point\n/** record a log/message's arguments to the cache and/or the console based on level and namespace */\nMetricsLogger.prototype.emit = function emit(level, namespace, logArguments) {\n    //this._emitToConsole( 'debug', 'MetricsLogger', [ 'emit:', level, namespace, logArguments ]);\n    var self = this;\n    namespace = namespace || self.options.defaultNamespace;\n    if (!level || !logArguments) {\n        return self;\n    }\n    // add to cache if proper level\n    //TODO: respect do not track?\n    //if( !navigator.doNotTrack && level >= self.options.logLevel ){\n    level = self._parseLevel(level);\n    if (level >= self.options.logLevel) {\n        self._addToCache(level, namespace, logArguments);\n    }\n    // also emit to consoleLogger if proper level for that\n    if (self.consoleLogger && level >= self.options.consoleLevel) {\n        self._emitToConsole(level, namespace, logArguments);\n    }\n    return self;\n};\n\n//----------------------------------------------------------------------------- cache\n/** add a message to the cache and if messages.length is high enough post them to the server */\nMetricsLogger.prototype._addToCache = function _addToCache(level, namespace, logArguments) {\n    this._emitToConsole(\"debug\", \"MetricsLogger\", [\n        \"_addToCache:\",\n        arguments,\n        this.options.addTime,\n        this.cache.length()\n    ]);\n    //this._emitToConsole( 'debug', 'MetricsLogger', [ '\\t logArguments:', logArguments ]);\n    var self = this;\n    // try add to the cache and if we've got _postSize number of entries, attempt to post them to the server\n    try {\n        var newLength = self.cache.add(self._buildEntry(level, namespace, logArguments));\n        if (newLength >= self._postSize) {\n            self._postCache();\n        }\n        // discard entry if an error occurs, but warn if level set to do so\n    } catch (err) {\n        self._emitToConsole(\"warn\", \"MetricsLogger\", [\n            \"Metrics logger could not stringify logArguments:\",\n            namespace,\n            logArguments\n        ]);\n        self._emitToConsole(\"error\", \"MetricsLogger\", [err]);\n    }\n    return self;\n};\n\n/** build a log cache entry object from the given level, namespace, and arguments (optionally adding timestamp */\nMetricsLogger.prototype._buildEntry = function _buildEntry(level, namespace, logArguments) {\n    this._emitToConsole(\"debug\", \"MetricsLogger\", [\"_buildEntry:\", arguments]);\n    var entry = {\n        level: level,\n        namespace: this.options.clientPrefix + namespace,\n        args: logArguments\n    };\n    if (this.options.addTime) {\n        entry.time = new Date().toISOString();\n    }\n    return entry;\n};\n\n/** post _postSize messages from the cache to the server, removing them if successful\n *      if the post fails, wait until maxCacheSize is accumulated instead and try again then\n *      in addition to the messages from the cache ('metrics'), any info from getPingData (if set) will be sent\n *      onServerResponse will be called (if set) with any response from the server\n */\nMetricsLogger.prototype._postCache = function _postCache(options) {\n    options = options || {};\n    this._emitToConsole(\"info\", \"MetricsLogger\", [\"_postCache\", options, this._postSize]);\n\n    // short circuit if we're already sending\n    if (!this.options.postUrl || this._sending) {\n        return jQuery.when({});\n    }\n\n    var self = this;\n    var postSize = options.count || self._postSize;\n\n    var // do not splice - remove after *successful* post\n    entries = self.cache.get(postSize);\n\n    var entriesLength = entries.length;\n\n    var // use the optional getPingData to add any extra info we may want to send\n    postData = typeof self.options.getPingData === \"function\" ? self.options.getPingData() : {};\n\n    //console.debug( postSize, entriesLength );\n\n    // add the metrics and send\n    postData.metrics = JSON.stringify(entries);\n    //console.debug( postData.metrics );\n    self._sending = true;\n    return jQuery\n        .post(self.options.postUrl, postData)\n        .always(() => {\n            self._sending = false;\n        })\n        .fail((xhr, status, message) => {\n            // if we failed the previous time, set the next post target to the max num of entries\n            self._postSize = self.options.maxCacheSize;\n            //TODO:??\n            // log this failure to explain any gap in metrics\n            self.emit(\"error\", \"MetricsLogger\", [\n                \"_postCache error:\",\n                xhr.readyState,\n                xhr.status,\n                xhr.responseJSON || xhr.responseText\n            ]);\n            //TODO: still doesn't solve the problem that when cache == max, post will be tried on every emit\n            //TODO: see _delayPost\n        })\n        .done(response => {\n            if (typeof self.options.onServerResponse === \"function\") {\n                self.options.onServerResponse(response);\n            }\n            // only remove if post successful\n            self.cache.remove(entriesLength);\n            //console.debug( 'removed entries:', entriesLength, 'size now:', self.cache.length() );\n            // if we succeeded, reset the post target to the normal num of entries\n            self._postSize = self.options.postSize;\n        });\n    // return the xhr promise\n};\n\n/** set _waiting to true and, after delayPostInMs, set it back to false */\nMetricsLogger.prototype._delayPost = function _delayPost() {\n    //TODO: this won't work between pages\n    var self = this;\n    self._waiting = setTimeout(() => {\n        self._waiting = null;\n    }, self.options.delayPostInMs);\n};\n\nfunction usefulToString(arg) {\n    var asStr = String(arg);\n    if (asStr == \"[object Object]\") {\n        asStr = JSON.stringify(arg);\n    }\n    return asStr;\n}\n\n//----------------------------------------------------------------------------- console\n/** output message to console based on level and consoleLogger type */\nMetricsLogger.prototype._emitToConsole = function _emitToConsole(level, namespace, logArguments) {\n    //console.debug( '_emitToConsole:', level, namespace, logArguments );\n    var self = this;\n\n    var whitelist = self.options.consoleNamespaceWhitelist;\n    if (!self.consoleLogger) {\n        return self;\n    }\n    // if a whitelist for namespaces is set, bail if this namespace is not in the list\n    if (whitelist && whitelist.indexOf(namespace) === -1) {\n        return self;\n    }\n\n    var args = Array.prototype.slice.call(logArguments, 0);\n    args.unshift(namespace);\n    if (self.options.consoleFlattenMessages) {\n        args = [args.map(usefulToString).join(\" \")];\n    }\n    //TODO: script location and/or source maps?\n    //TODO: branch on navigator.userAgent == AIIEEE - it only has log\n    if (level >= MetricsLogger.METRIC && typeof self.consoleLogger.info === \"function\") {\n        return self.consoleLogger.info.apply(self.consoleLogger, args);\n    } else if (level >= MetricsLogger.ERROR && typeof self.consoleLogger.error === \"function\") {\n        return self.consoleLogger.error.apply(self.consoleLogger, args);\n    } else if (level >= MetricsLogger.WARN && typeof self.consoleLogger.warn === \"function\") {\n        self.consoleLogger.warn.apply(self.consoleLogger, args);\n    } else if (level >= MetricsLogger.INFO && typeof self.consoleLogger.info === \"function\") {\n        self.consoleLogger.info.apply(self.consoleLogger, args);\n    } else if (level >= MetricsLogger.DEBUG && typeof self.consoleLogger.debug === \"function\") {\n        self.consoleLogger.debug.apply(self.consoleLogger, args);\n    } else if (typeof self.consoleLogger.log === \"function\") {\n        self.consoleLogger.log.apply(self.consoleLogger, args);\n    }\n    return self;\n};\n\n//----------------------------------------------------------------------------- shortcuts\n// generic functions when logging from non-namespaced object (e.g. templates)\n/** log to default namespace */\nMetricsLogger.prototype.log = function log() {\n    this.emit(1, this.options.defaultNamespace, Array.prototype.slice.call(arguments, 0));\n};\n\n/** debug to default namespace */\nMetricsLogger.prototype.debug = function debug() {\n    this.emit(MetricsLogger.DEBUG, this.options.defaultNamespace, Array.prototype.slice.call(arguments, 0));\n};\n\n/** info to default namespace */\nMetricsLogger.prototype.info = function info() {\n    this.emit(MetricsLogger.INFO, this.options.defaultNamespace, Array.prototype.slice.call(arguments, 0));\n};\n\n/** warn to default namespace */\nMetricsLogger.prototype.warn = function warn() {\n    this.emit(MetricsLogger.WARN, this.options.defaultNamespace, Array.prototype.slice.call(arguments, 0));\n};\n\n/** error to default namespace */\nMetricsLogger.prototype.error = function error() {\n    this.emit(MetricsLogger.ERROR, this.options.defaultNamespace, Array.prototype.slice.call(arguments, 0));\n};\n\n/** metric to default namespace */\nMetricsLogger.prototype.metric = function metric() {\n    this.emit(MetricsLogger.METRIC, this.options.defaultNamespace, Array.prototype.slice.call(arguments, 0));\n};\n\n/* ============================================================================\nTODO:\n    need a performance pass - the JSON un/parsing is a bit much\n\n============================================================================ */\n/** @class LoggingCache\n *  Simple implementation of cache wrapping an array.\n *\n *  Formats an entry before it's cached and only keeps options.maxSize number\n *  of entries. Older entries are deleted first.\n */\nfunction LoggingCache(options) {\n    var self = this;\n    return self._init(options || {});\n}\n\n/** default options */\nLoggingCache.defaultOptions = {\n    /** maximum number of entries to keep before discarding oldest */\n    maxSize: 5000\n};\n\n/** initialize with options */\nLoggingCache.prototype._init = function _init(options) {\n    if (!this._hasStorage()) {\n        //TODO: fall back to jstorage\n        throw new Error(\"LoggingCache needs localStorage\");\n    }\n    if (!options.key) {\n        throw new Error(\"LoggingCache needs key for localStorage\");\n    }\n    this.key = options.key;\n    this._initStorage();\n\n    this.maxSize = options.maxSize || LoggingCache.defaultOptions.maxSize;\n    return this;\n};\n\n/** tests for localStorage fns */\nLoggingCache.prototype._hasStorage = function _hasStorage() {\n    //TODO: modernizr\n    var test = \"test\";\n    try {\n        localStorage.setItem(test, test);\n        localStorage.removeItem(test);\n        return true;\n    } catch (e) {\n        return false;\n    }\n};\n\n/** if no localStorage set for key, initialize to empty array */\nLoggingCache.prototype._initStorage = function _initStorage() {\n    if (localStorage.getItem(this.key) === null) {\n        return this.empty();\n    }\n    return this;\n};\n\n/** add an entry to the cache, removing the oldest beforehand if size >= maxSize */\nLoggingCache.prototype.add = function add(entry) {\n    var self = this;\n    var _cache = self._fetchAndParse();\n    var overage = _cache.length + 1 - self.maxSize;\n    if (overage > 0) {\n        _cache.splice(0, overage);\n    }\n    _cache.push(entry);\n    self._unparseAndStore(_cache);\n    return _cache.length;\n};\n\n/** get the entries from localStorage and parse them */\nLoggingCache.prototype._fetchAndParse = function _fetchAndParse() {\n    var self = this;\n    return JSON.parse(localStorage.getItem(self.key));\n};\n\n/** stringify the entries and put them in localStorage */\nLoggingCache.prototype._unparseAndStore = function _unparseAndStore(entries) {\n    var self = this;\n    return localStorage.setItem(self.key, JSON.stringify(entries));\n};\n\n///** process the entry before caching */\n//LoggingCache.prototype._preprocessEntry = function _preprocessEntry( entry ){\n//    return JSON.stringify( entry );\n//};\n\n/** return the length --- oh, getters where are you? */\nLoggingCache.prototype.length = function length() {\n    return this._fetchAndParse().length;\n};\n\n/** get count number of entries starting with the oldest */\nLoggingCache.prototype.get = function get(count) {\n    return this._fetchAndParse().slice(0, count);\n};\n\n/** remove count number of entries starting with the oldest */\nLoggingCache.prototype.remove = function remove(count) {\n    var _cache = this._fetchAndParse();\n    var removed = _cache.splice(0, count);\n    this._unparseAndStore(_cache);\n    return removed;\n};\n\n/** empty/clear the entire cache */\nLoggingCache.prototype.empty = function empty() {\n    localStorage.setItem(this.key, \"[]\");\n    return this;\n};\n\n/** stringify count number of entries (but do not remove) */\nLoggingCache.prototype.stringify = function stringify(count) {\n    return JSON.stringify(this.get(count));\n};\n\n/** outputs entire cache to console */\nLoggingCache.prototype.print = function print() {\n    // popup? (really, carl? a popup?) - easier to copy/paste\n    console.log(JSON.stringify(this._fetchAndParse(), null, \"  \"));\n};\n\n//=============================================================================\nexport default {\n    MetricsLogger: MetricsLogger,\n    LoggingCache: LoggingCache\n};\n"]}