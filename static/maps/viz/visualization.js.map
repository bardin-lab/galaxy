{"version":3,"sources":["viz/visualization.js"],"names":["_","CustomToJSON","toJSON","self","this","json","each","constructor","to_json_keys","k","val","get","to_json_mappers","closing_events","default_font","buttons","undefined","Galaxy","modal","dummy_context","dummy_canvas","getContext","Add","font","tabs","$","measureText","width","requests","data","data_type","hda_ldda","load_pattern","extend","CanvasManager","prototype","key","path","when","apply","image","Image","src","root","onload","patterns","createPattern","get_pattern","new_canvas","canvas","manager","Cache","Backbone","defaults","num_elements","obj_cache","char_width_px","key_ary","initialize","options","attributes","key_str","toString","index","splice","value","length","shift","move_key_to_end","push","clear","size","most_recently_added","dataset","genome","min_region_size","filters_manager","data_mode_compatible","entry","mode","can_subset","call","initial_entries","add_data","entries","set","GenomeDataManager","region","data_is_ready","ready_deferred","Deferred","query_type","ss_deferred","_util2","default","ServerStateDeferred","ajax_settings","dataType","interval","success_fn","response","go","then","resolve","search_features","query","params","getJSON","url","extra_params","low","high","resolution","filter_names","filters","i","name","JSON","stringify","result","set_data","load_data","chrom","is_deferred","entry_region","filter_cols","contains","is_subregion","subset_entry","last_request","trim","set_elt","DEEP_DATA_REQ","BROAD_DATA_REQ","get_more_data","req_type","cur_data","query_low","start_val","max_high","copy","data_manager","query_region","new_data_available","new_data_request","_mark_stale","console","concat","max_low","message","replace","log","can_get_more_detailed_data","get_elt","get_more_detailed_data","detail_multiplier","dataset_type","stale","gw_data","map","chrom_info","GenomeRegion","num_samples","start","end","len","chrom_data","all_data_available","deferred","genome_wide_data","get_genome_wide_data","bigwig","subregion","filter","data_point","refseq","seq_start","slice","subregion_data","same","subset_fns","GenomeReferenceDataManager","dataset_placeholder","Model","data_url","chroms_info","id","dbkey","get_chroms_info","get_chrom_region","chr_name","find","str_val","from_str","pieces","split","start_end","parseInt","on","compute_overlap","a_region","first_chrom","second_chrom","first_start","second_start","first_end","second_end","overlap_results","DIF_CHROMS","BEFORE","OVERLAP_START","CONTAINS","AFTER","CONTAINED_BY","OVERLAP_END","overlap","chrom_len","overlaps","intersection","Collection","BrowserBookmark","GenomeRegionCollection","BrowserBookmarkCollection","model","BackboneTrack","_data2","Dataset","default_value","label","models","type","_config2","ConfigSettingCollection","from_models_and_saved_values","prefs","preloaded_data","init_data","p","color","d","BackboneTrackCollection","Visualization","title","save","ajax","vis_json","GenomeVisualization","drawables","bookmarks","viewport","unset","tracks","add_tracks","view","add","dummy","obj_type","content_visible","TrackBrowserRouter","Router","navigate","change_location","route","new_loc","Genome","select_datasets","history_grid","_gridView2","url_base","embedded","library_grid","_uiTabs2","_localization2","append","$el","show","body","Cancel","hide","window","current","track_defs","arguments","Array","arg"],"mappings":"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","file":"../../scripts/viz/visualization.js","sourcesContent":["import _l from \"utils/localization\";\nimport * as _ from \"libs/underscore\";\nimport data_mod from \"mvc/dataset/data\";\nimport util_mod from \"viz/trackster/util\";\nimport config_mod from \"utils/config\";\nimport GridView from \"mvc/grid/grid-view\";\nimport Tabs from \"mvc/ui/ui-tabs\";\nimport Ui from \"mvc/ui/ui-misc\";\n/**\n * Mixin for returning custom JSON representation from toJSON. Class attribute to_json_keys defines a set of attributes\n * to include in the representation; to_json_mappers defines mappers for returned objects.\n */\nvar CustomToJSON = {\n    /**\n     * Returns JSON representation of object using to_json_keys and to_json_mappers.\n     */\n    toJSON: function() {\n        var self = this;\n        var json = {};\n        _.each(self.constructor.to_json_keys, k => {\n            var val = self.get(k);\n            if (k in self.constructor.to_json_mappers) {\n                val = self.constructor.to_json_mappers[k](val, self);\n            }\n            json[k] = val;\n        });\n        return json;\n    }\n};\n\n/**\n * Model, view, and controller objects for Galaxy visualization framework.\n *\n * Models have no references to views, instead using events to indicate state\n * changes; this is advantageous because multiple views can use the same object\n * and models can be used without views.\n */\n\n/**\n * Use a popup grid to select datasets from histories or libraries. After datasets are selected,\n * track definitions are obtained from the server and the success_fn is called with the list of\n * definitions for selected datasets.\n */\nvar select_datasets = (filters, success_fn) => {\n    // history dataset selection tab\n    var history_grid = new GridView({\n        url_base: `${Galaxy.root}visualization/list_history_datasets`,\n        filters: filters,\n        embedded: true\n    });\n\n    // library dataset selection tab\n    var library_grid = new GridView({\n        url_base: `${Galaxy.root}visualization/list_library_datasets`,\n        embedded: true\n    });\n\n    // build tabs\n    var tabs = new Tabs.View();\n    tabs.add({\n        id: \"histories\",\n        title: _l(\"Histories\"),\n        $el: $(\"<div/>\").append(history_grid.$el)\n    });\n    tabs.add({\n        id: \"libraries\",\n        title: _l(\"Libraries\"),\n        $el: $(\"<div/>\").append(library_grid.$el)\n    });\n\n    // modal\n    Galaxy.modal.show({\n        title: _l(\"Select datasets for new tracks\"),\n        body: tabs.$el,\n        closing_events: true,\n        buttons: {\n            Cancel: function() {\n                Galaxy.modal.hide();\n            },\n            Add: function() {\n                var requests = [];\n                tabs.$(\"input.grid-row-select-checkbox[name=id]:checked\").each(function() {\n                    window.console.log($(this).val());\n                    requests[requests.length] = $.ajax({\n                        url: `${Galaxy.root}api/datasets/${$(this).val()}`,\n                        dataType: \"json\",\n                        data: {\n                            data_type: \"track_config\",\n                            hda_ldda: tabs.current() == \"histories\" ? \"hda\" : \"ldda\"\n                        }\n                    });\n                });\n                // To preserve order, wait until there are definitions for all tracks and then add\n                // them sequentially.\n                $.when.apply($, requests).then(function() {\n                    // jQuery always returns an Array for arguments, so need to look at first element\n                    // to determine whether multiple requests were made and consequently how to\n                    // map arguments to track definitions.\n                    var track_defs = arguments[0] instanceof Array ? $.map(arguments, arg => arg[0]) : [arguments[0]];\n                    success_fn(track_defs);\n                });\n                Galaxy.modal.hide();\n            }\n        }\n    });\n};\n\n// --------- Models ---------\n\n/**\n * Canvas manager is used to create canvases for browsers as well as providing a pattern cache\n */\nvar CanvasManager = function(default_font) {\n    this.default_font = default_font !== undefined ? default_font : \"9px Monaco, Lucida Console, monospace\";\n\n    this.dummy_canvas = this.new_canvas();\n    this.dummy_context = this.dummy_canvas.getContext(\"2d\");\n    this.dummy_context.font = this.default_font;\n\n    this.char_width_px = this.dummy_context.measureText(\"A\").width;\n\n    this.patterns = {};\n\n    // FIXME: move somewhere to make this more general\n    this.load_pattern(\"right_strand\", \"/visualization/strand_right.png\");\n    this.load_pattern(\"left_strand\", \"/visualization/strand_left.png\");\n    this.load_pattern(\"right_strand_inv\", \"/visualization/strand_right_inv.png\");\n    this.load_pattern(\"left_strand_inv\", \"/visualization/strand_left_inv.png\");\n};\n\n_.extend(CanvasManager.prototype, {\n    load_pattern: function(key, path) {\n        var patterns = this.patterns;\n        var dummy_context = this.dummy_context;\n        var image = new Image();\n        image.src = `${Galaxy.root}static/images${path}`;\n        image.onload = () => {\n            patterns[key] = dummy_context.createPattern(image, \"repeat\");\n        };\n    },\n    get_pattern: function(key) {\n        return this.patterns[key];\n    },\n    new_canvas: function() {\n        var canvas = $(\"<canvas/>\")[0];\n        // Keep a reference back to the manager\n        canvas.manager = this;\n        return canvas;\n    }\n});\n\n/**\n * Generic cache that handles key/value pairs. Keys can be any object that can be\n * converted to a String and compared.\n */\nvar Cache = Backbone.Model.extend({\n    defaults: {\n        num_elements: 20,\n        // Objects in cache; indexes into cache are strings of keys.\n        obj_cache: null,\n        // key_ary contains keys for objects in cache.\n        key_ary: null\n    },\n\n    initialize: function(options) {\n        this.clear();\n    },\n\n    /**\n     * Get an element from the cache using its key.\n     */\n    get_elt: function(key) {\n        var obj_cache = this.attributes.obj_cache;\n        var key_ary = this.attributes.key_ary;\n        var key_str = key.toString();\n\n        var index = _.indexOf(key_ary, k => k.toString() === key_str);\n\n        // Update cache.\n        if (index !== -1) {\n            // Object is in cache, so update it.\n            if (obj_cache[key_str].stale) {\n                // Object is stale: remove key and object.\n                key_ary.splice(index, 1);\n                delete obj_cache[key_str];\n            } else {\n                // Move key to back because it is most recently used.\n                this.move_key_to_end(key, index);\n            }\n        }\n\n        return obj_cache[key_str];\n    },\n\n    /**\n     * Put an element into the cache.\n     */\n    set_elt: function(key, value) {\n        var obj_cache = this.attributes.obj_cache;\n        var key_ary = this.attributes.key_ary;\n        var key_str = key.toString();\n        var num_elements = this.attributes.num_elements;\n\n        // Update keys, objects.\n        if (!obj_cache[key_str]) {\n            // Add object to cache.\n\n            if (key_ary.length >= num_elements) {\n                // Cache full, so remove first element.\n                var deleted_key = key_ary.shift();\n                delete obj_cache[deleted_key.toString()];\n            }\n\n            // Add key.\n            key_ary.push(key);\n        }\n\n        // Add object.\n        obj_cache[key_str] = value;\n        return value;\n    },\n\n    /**\n     * Move key to end of cache. Keys are removed from the front, so moving a key to the end\n     * delays the key's removal.\n     */\n    move_key_to_end: function(key, index) {\n        this.attributes.key_ary.splice(index, 1);\n        this.attributes.key_ary.push(key);\n    },\n\n    /**\n     * Clear all elements from the cache.\n     */\n    clear: function() {\n        this.attributes.obj_cache = {};\n        this.attributes.key_ary = [];\n    },\n\n    /** Returns the number of elements in the cache. */\n    size: function() {\n        return this.attributes.key_ary.length;\n    },\n\n    /** Returns key most recently added to cache. */\n    most_recently_added: function() {\n        return this.size() === 0\n            ? null\n            : // Most recent key is at the end of key array.\n              this.attributes.key_ary[this.attributes.key_ary.length - 1];\n    }\n});\n\n/**\n * Data manager for genomic data. Data is connected to and queryable by genomic regions.\n */\nvar GenomeDataManager = Cache.extend({\n    defaults: _.extend({}, Cache.prototype.defaults, {\n        dataset: null,\n        genome: null,\n        init_data: null,\n        min_region_size: 200,\n        filters_manager: null,\n        data_type: \"data\",\n        data_mode_compatible: function(entry, mode) {\n            return true;\n        },\n        can_subset: function(entry) {\n            return false;\n        }\n    }),\n\n    /**\n     * Initialization.\n     */\n    initialize: function(options) {\n        Cache.prototype.initialize.call(this);\n\n        // Set initial entries in data manager.\n        var initial_entries = this.get(\"init_data\");\n        if (initial_entries) {\n            this.add_data(initial_entries);\n        }\n    },\n\n    /**\n     * Add data entries to manager; each entry should be a dict with attributes region (key), data, and data_type.\n     * If necessary, manager size is increased to hold all data.\n     */\n    add_data: function(entries) {\n        // Increase size to accomodate all entries.\n        if (this.get(\"num_elements\") < entries.length) {\n            this.set(\"num_elements\", entries.length);\n        }\n\n        // Put data into manager.\n        var self = this;\n        _.each(entries, entry => {\n            self.set_data(entry.region, entry);\n        });\n    },\n\n    /**\n     * Returns deferred that resolves to true when dataset is ready (or false if dataset\n     * cannot be used).\n     */\n    data_is_ready: function() {\n        var dataset = this.get(\"dataset\");\n        var ready_deferred = $.Deferred();\n\n        var // If requesting raw data, query dataset state; if requesting (converted) data,\n        // need to query converted datasets state.\n        query_type =\n            this.get(\"data_type\") === \"raw_data\"\n                ? \"state\"\n                : this.get(\"data_type\") === \"data\" ? \"converted_datasets_state\" : \"error\";\n\n        var ss_deferred = new util_mod.ServerStateDeferred({\n            ajax_settings: {\n                url: this.get(\"dataset\").url(),\n                data: {\n                    hda_ldda: dataset.get(\"hda_ldda\"),\n                    data_type: query_type\n                },\n                dataType: \"json\"\n            },\n            interval: 5000,\n            success_fn: function(response) {\n                return response !== \"pending\";\n            }\n        });\n\n        $.when(ss_deferred.go()).then(response => {\n            ready_deferred.resolve(response === \"ok\" || response === \"data\");\n        });\n        return ready_deferred;\n    },\n\n    /**\n     * Perform a feature search from server; returns Deferred object that resolves when data is available.\n     */\n    search_features: function(query) {\n        var dataset = this.get(\"dataset\");\n\n        var params = {\n            query: query,\n            hda_ldda: dataset.get(\"hda_ldda\"),\n            data_type: \"features\"\n        };\n\n        return $.getJSON(dataset.url(), params);\n    },\n\n    /**\n     * Load data from server and manages data entries. Adds a Deferred to manager\n     * for region; when data becomes available, replaces Deferred with data.\n     * Returns the Deferred that resolves when data is available.\n     */\n    load_data: function(region, mode, resolution, extra_params) {\n        // Setup data request params.\n        var dataset = this.get(\"dataset\");\n\n        var params = {\n            data_type: this.get(\"data_type\"),\n            chrom: region.get(\"chrom\"),\n            low: region.get(\"start\"),\n            high: region.get(\"end\"),\n            mode: mode,\n            resolution: resolution,\n            hda_ldda: dataset.get(\"hda_ldda\")\n        };\n\n        $.extend(params, extra_params);\n\n        // Add track filters to params.\n        var filters_manager = this.get(\"filters_manager\");\n        if (filters_manager) {\n            var filter_names = [];\n            var filters = filters_manager.filters;\n            for (var i = 0; i < filters.length; i++) {\n                filter_names.push(filters[i].name);\n            }\n            params.filter_cols = JSON.stringify(filter_names);\n        }\n\n        // Do request.\n        var manager = this;\n\n        var entry = $.getJSON(dataset.url(), params, result => {\n            // Add region to the result.\n            result.region = region;\n            manager.set_data(region, result);\n        });\n\n        this.set_data(region, entry);\n        return entry;\n    },\n\n    /**\n     * Get data from dataset.\n     */\n    get_data: function(region, mode, resolution, extra_params) {\n        // Look for entry and return if it's a deferred or if data available is compatible with mode.\n        var entry = this.get_elt(region);\n        if (entry && (util_mod.is_deferred(entry) || this.get(\"data_mode_compatible\")(entry, mode))) {\n            return entry;\n        }\n\n        //\n        // Look in cache for data that can be used.\n        // TODO: this logic could be improved if the visualization knew whether\n        // the data was \"index\" or \"data.\"\n        //\n        var key_ary = this.get(\"key_ary\");\n\n        var obj_cache = this.get(\"obj_cache\");\n        var entry_region;\n        var is_subregion;\n        for (var i = 0; i < key_ary.length; i++) {\n            entry_region = key_ary[i];\n\n            if (entry_region.contains(region)) {\n                is_subregion = true;\n\n                // This entry has data in the requested range. Return if data\n                // is compatible and can be subsetted.\n                entry = obj_cache[entry_region.toString()];\n                if (\n                    util_mod.is_deferred(entry) ||\n                    (this.get(\"data_mode_compatible\")(entry, mode) && this.get(\"can_subset\")(entry))\n                ) {\n                    this.move_key_to_end(entry_region, i);\n\n                    // If there's data, subset it.\n                    if (!util_mod.is_deferred(entry)) {\n                        var subset_entry = this.subset_entry(entry, region);\n                        this.set_data(region, subset_entry);\n                        entry = subset_entry;\n                    }\n\n                    return entry;\n                }\n            }\n        }\n\n        // FIXME: There _may_ be instances where region is a subregion of another entry but cannot be\n        // subsetted. For these cases, do not increase length because region will never be found (and\n        // an infinite loop will occur.)\n        // If needed, extend region to make it minimum size.\n        if (!is_subregion && region.length() < this.attributes.min_region_size) {\n            // IDEA: alternative heuristic is to find adjacent cache entry to region and use that to extend.\n            // This would prevent bad extensions when zooming in/out while still preserving the behavior\n            // below.\n\n            // Use copy of region to avoid changing actual region.\n            region = region.copy();\n\n            // Use heuristic to extend region: extend relative to last data request.\n            var last_request = this.most_recently_added();\n            if (!last_request || region.get(\"start\") > last_request.get(\"start\")) {\n                // This request is after the last request, so extend right.\n                region.set(\"end\", region.get(\"start\") + this.attributes.min_region_size);\n            } else {\n                // This request is after the last request, so extend left.\n                region.set(\"start\", region.get(\"end\") - this.attributes.min_region_size);\n            }\n\n            // Trim region to avoid invalid coordinates.\n            region.set(\"genome\", this.attributes.genome);\n            region.trim();\n        }\n\n        return this.load_data(region, mode, resolution, extra_params);\n    },\n\n    /**\n     * Alias for set_elt for readbility.\n     */\n    set_data: function(region, entry) {\n        this.set_elt(region, entry);\n    },\n\n    /** \"Deep\" data request; used as a parameter for DataManager.get_more_data() */\n    DEEP_DATA_REQ: \"deep\",\n\n    /** \"Broad\" data request; used as a parameter for DataManager.get_more_data() */\n    BROAD_DATA_REQ: \"breadth\",\n\n    /**\n     * Gets more data for a region using either a depth-first or a breadth-first approach.\n     */\n    get_more_data: function(region, mode, resolution, extra_params, req_type) {\n        var cur_data = this._mark_stale(region);\n        if (!(cur_data && this.get(\"data_mode_compatible\")(cur_data, mode))) {\n            console.log(\"ERROR: problem with getting more data: current data is not compatible\");\n            return;\n        }\n\n        //\n        // Set parameters based on request type.\n        //\n        var query_low = region.get(\"start\");\n        if (req_type === this.DEEP_DATA_REQ) {\n            // Use same interval but set start_val to skip data that's already in cur_data.\n            $.extend(extra_params, {\n                start_val: cur_data.data.length + 1\n            });\n        } else if (req_type === this.BROAD_DATA_REQ) {\n            // To get past an area of extreme feature depth, set query low to be after either\n            // (a) the maximum high or HACK/FIXME (b) the end of the last feature returned.\n            query_low = (cur_data.max_high ? cur_data.max_high : cur_data.data[cur_data.data.length - 1][2]) + 1;\n        }\n        var query_region = region.copy().set(\"start\", query_low);\n\n        //\n        // Get additional data, append to current data, and set new data. Use a custom deferred object\n        // to signal when new data is available.\n        //\n        var data_manager = this;\n\n        var new_data_request = this.load_data(query_region, mode, resolution, extra_params);\n\n        var new_data_available = $.Deferred();\n        // load_data sets cache to new_data_request, but use custom deferred object so that signal and data\n        // is all data, not just new data.\n        this.set_data(region, new_data_available);\n        $.when(new_data_request).then(result => {\n            // Update data and message.\n            if (result.data) {\n                result.data = cur_data.data.concat(result.data);\n                if (result.max_low) {\n                    result.max_low = cur_data.max_low;\n                }\n                if (result.message) {\n                    // HACK: replace number in message with current data length. Works but is ugly.\n                    result.message = result.message.replace(/[0-9]+/, result.data.length);\n                }\n            }\n            data_manager.set_data(region, result);\n            new_data_available.resolve(result);\n        });\n        return new_data_available;\n    },\n\n    /**\n     * Returns true if more detailed data can be obtained for entry.\n     */\n    can_get_more_detailed_data: function(region) {\n        var cur_data = this.get_elt(region);\n\n        // Can only get more detailed data for bigwig data that has less than 8000 data points.\n        // Summary tree returns *way* too much data, and 8000 data points ~ 500KB.\n        return cur_data.dataset_type === \"bigwig\" && cur_data.data.length < 8000;\n    },\n\n    /**\n     * Returns more detailed data for an entry.\n     */\n    get_more_detailed_data: function(region, mode, resolution, detail_multiplier, extra_params) {\n        // Mark current entry as stale.\n        var cur_data = this._mark_stale(region);\n        if (!cur_data) {\n            console.log(\"ERROR getting more detailed data: no current data\");\n            return;\n        }\n\n        if (!extra_params) {\n            extra_params = {};\n        }\n\n        // Use additional parameters to get more detailed data.\n        if (cur_data.dataset_type === \"bigwig\") {\n            // FIXME: constant should go somewhere.\n            extra_params.num_samples = 1000 * detail_multiplier;\n        }\n\n        return this.load_data(region, mode, resolution, extra_params);\n    },\n\n    /**\n     * Marks cache data as stale.\n     */\n    _mark_stale: function(region) {\n        var entry = this.get_elt(region);\n        if (!entry) {\n            console.log(\"ERROR: no data to mark as stale: \", this.get(\"dataset\"), region.toString());\n        }\n        entry.stale = true;\n        return entry;\n    },\n\n    /**\n     * Returns an array of data with each entry representing one chromosome/contig\n     * of data or, if data is not available, returns a Deferred that resolves to the\n     * data when it becomes available.\n     */\n    get_genome_wide_data: function(genome) {\n        // -- Get all data. --\n\n        var self = this;\n\n        var all_data_available = true;\n\n        var //  Map chromosome info into genome data.\n        gw_data = _.map(genome.get(\"chroms_info\").chrom_info, chrom_info => {\n            var chrom_data = self.get_elt(\n                new GenomeRegion({\n                    chrom: chrom_info.chrom,\n                    start: 0,\n                    end: chrom_info.len\n                })\n            );\n\n            // Set flag if data is not available.\n            if (!chrom_data) {\n                all_data_available = false;\n            }\n\n            return chrom_data;\n        });\n\n        // -- If all data is available, return it. --\n        if (all_data_available) {\n            return gw_data;\n        }\n\n        // -- All data is not available, so load from server. --\n\n        var deferred = $.Deferred();\n        $.getJSON(this.get(\"dataset\").url(), { data_type: \"genome_data\" }, genome_wide_data => {\n            self.add_data(genome_wide_data.data);\n            deferred.resolve(genome_wide_data.data);\n        });\n\n        return deferred;\n    },\n\n    /**\n     * Returns entry with only data in the subregion.\n     */\n    subset_entry: function(entry, subregion) {\n        // Dictionary from entry type to function for subsetting data.\n        var subset_fns = {\n            bigwig: function(data, subregion) {\n                return _.filter(\n                    data,\n                    data_point => data_point[0] >= subregion.get(\"start\") && data_point[0] <= subregion.get(\"end\")\n                );\n            },\n            refseq: function(data, subregion) {\n                var seq_start = subregion.get(\"start\") - entry.region.get(\"start\");\n                return entry.data.slice(seq_start, seq_start + subregion.length());\n            }\n        };\n\n        // Subset entry if there is a function for subsetting and regions are not the same.\n        var subregion_data = entry.data;\n        if (!entry.region.same(subregion) && entry.dataset_type in subset_fns) {\n            subregion_data = subset_fns[entry.dataset_type](entry.data, subregion);\n        }\n\n        // Return entry with subregion's data.\n        return {\n            region: subregion,\n            data: subregion_data,\n            dataset_type: entry.dataset_type\n        };\n    }\n});\n\nvar GenomeReferenceDataManager = GenomeDataManager.extend({\n    initialize: function(options) {\n        // Use generic object in place of dataset and set urlRoot to fetch data.\n        var dataset_placeholder = new Backbone.Model();\n        dataset_placeholder.urlRoot = options.data_url;\n        this.set(\"dataset\", dataset_placeholder);\n    },\n\n    load_data: function(region, mode, resolution, extra_params) {\n        // Fetch data if region is not too large.\n        return region.length() <= 100000\n            ? GenomeDataManager.prototype.load_data.call(this, region, mode, resolution, extra_params)\n            : { data: null, region: region };\n    }\n});\n\n/**\n * A genome build.\n */\nvar Genome = Backbone.Model.extend({\n    defaults: {\n        name: null,\n        key: null,\n        chroms_info: null\n    },\n\n    initialize: function(options) {\n        this.id = options.dbkey;\n    },\n\n    /**\n     * Shorthand for getting to chromosome information.\n     */\n    get_chroms_info: function() {\n        return this.attributes.chroms_info.chrom_info;\n    },\n\n    /**\n     * Returns a GenomeRegion object denoting a complete chromosome.\n     */\n    get_chrom_region: function(chr_name) {\n        // FIXME: use findWhere in underscore 1.4\n        var chrom_info = _.find(this.get_chroms_info(), chrom_info => chrom_info.chrom === chr_name);\n        return new GenomeRegion({\n            chrom: chrom_info.chrom,\n            end: chrom_info.len\n        });\n    },\n\n    /** Returns the length of a chromosome. */\n    get_chrom_len: function(chr_name) {\n        // FIXME: use findWhere in underscore 1.4\n        return _.find(this.get_chroms_info(), chrom_info => chrom_info.chrom === chr_name).len;\n    }\n});\n\n/**\n * A genomic region.\n */\nvar GenomeRegion = Backbone.Model.extend(\n    {\n        defaults: {\n            chrom: null,\n            start: 0,\n            end: 0,\n            str_val: null,\n            genome: null\n        },\n\n        /**\n         * Returns true if this region is the same as a given region.\n         * It does not test the genome right now.\n         */\n        same: function(region) {\n            return (\n                this.attributes.chrom === region.get(\"chrom\") &&\n                this.attributes.start === region.get(\"start\") &&\n                this.attributes.end === region.get(\"end\")\n            );\n        },\n\n        /**\n         * If from_str specified, use it to initialize attributes.\n         */\n        initialize: function(options) {\n            if (options.from_str) {\n                var pieces = options.from_str.split(\":\");\n                var chrom = pieces[0];\n                var start_end = pieces[1].split(\"-\");\n                this.set({\n                    chrom: chrom,\n                    start: parseInt(start_end[0], 10),\n                    end: parseInt(start_end[1], 10)\n                });\n            }\n\n            // Keep a copy of region's string value for fast lookup.\n            this.attributes.str_val = `${this.get(\"chrom\")}:${this.get(\"start\")}-${this.get(\"end\")}`;\n\n            // Set str_val on attribute change.\n            this.on(\n                \"change\",\n                function() {\n                    this.attributes.str_val = `${this.get(\"chrom\")}:${this.get(\"start\")}-${this.get(\"end\")}`;\n                },\n                this\n            );\n        },\n\n        copy: function() {\n            return new GenomeRegion({\n                chrom: this.get(\"chrom\"),\n                start: this.get(\"start\"),\n                end: this.get(\"end\")\n            });\n        },\n\n        length: function() {\n            return this.get(\"end\") - this.get(\"start\");\n        },\n\n        /** Returns region in canonical form chrom:start-end */\n        toString: function() {\n            return this.attributes.str_val;\n        },\n\n        toJSON: function() {\n            return {\n                chrom: this.get(\"chrom\"),\n                start: this.get(\"start\"),\n                end: this.get(\"end\")\n            };\n        },\n\n        /**\n         * Compute the type of overlap between this region and another region. The overlap is computed relative to the given/second region;\n         * hence, OVERLAP_START indicates that the first region overlaps the start (but not the end) of the second region.\n         */\n        compute_overlap: function(a_region) {\n            var first_chrom = this.get(\"chrom\");\n            var second_chrom = a_region.get(\"chrom\");\n            var first_start = this.get(\"start\");\n            var second_start = a_region.get(\"start\");\n            var first_end = this.get(\"end\");\n            var second_end = a_region.get(\"end\");\n            var overlap;\n\n            // Compare chroms.\n            if (first_chrom && second_chrom && first_chrom !== second_chrom) {\n                return GenomeRegion.overlap_results.DIF_CHROMS;\n            }\n\n            // Compare regions.\n            if (first_start < second_start) {\n                if (first_end < second_start) {\n                    overlap = GenomeRegion.overlap_results.BEFORE;\n                } else if (first_end < second_end) {\n                    overlap = GenomeRegion.overlap_results.OVERLAP_START;\n                } else {\n                    // first_end >= second_end\n                    overlap = GenomeRegion.overlap_results.CONTAINS;\n                }\n            } else if (first_start > second_start) {\n                if (first_start > second_end) {\n                    overlap = GenomeRegion.overlap_results.AFTER;\n                } else if (first_end <= second_end) {\n                    overlap = GenomeRegion.overlap_results.CONTAINED_BY;\n                } else {\n                    overlap = GenomeRegion.overlap_results.OVERLAP_END;\n                }\n            } else {\n                // first_start === second_start\n                overlap =\n                    first_end >= second_end\n                        ? GenomeRegion.overlap_results.CONTAINS\n                        : GenomeRegion.overlap_results.CONTAINED_BY;\n            }\n\n            return overlap;\n        },\n\n        /**\n         * Trim a region to match genome's constraints.\n         */\n        trim: function(genome) {\n            // Assume that all chromosome/contigs start at 0.\n            if (this.attributes.start < 0) {\n                this.attributes.start = 0;\n            }\n\n            // Only try to trim the end if genome is set.\n            if (this.attributes.genome) {\n                var chrom_len = this.attributes.genome.get_chrom_len(this.attributes.chrom);\n                if (this.attributes.end > chrom_len) {\n                    this.attributes.end = chrom_len - 1;\n                }\n            }\n\n            return this;\n        },\n\n        /**\n         * Returns true if this region contains a given region.\n         */\n        contains: function(a_region) {\n            return this.compute_overlap(a_region) === GenomeRegion.overlap_results.CONTAINS;\n        },\n\n        /**\n         * Returns true if regions overlap.\n         */\n        overlaps: function(a_region) {\n            return (\n                _.intersection(\n                    [this.compute_overlap(a_region)],\n                    [\n                        GenomeRegion.overlap_results.DIF_CHROMS,\n                        GenomeRegion.overlap_results.BEFORE,\n                        GenomeRegion.overlap_results.AFTER\n                    ]\n                ).length === 0\n            );\n        }\n    },\n    {\n        overlap_results: {\n            DIF_CHROMS: 1000,\n            BEFORE: 1001,\n            CONTAINS: 1002,\n            OVERLAP_START: 1003,\n            OVERLAP_END: 1004,\n            CONTAINED_BY: 1005,\n            AFTER: 1006\n        }\n    }\n);\n\nvar GenomeRegionCollection = Backbone.Collection.extend({\n    model: GenomeRegion\n});\n\n/**\n * A genome browser bookmark.\n */\nvar BrowserBookmark = Backbone.Model.extend({\n    defaults: {\n        region: null,\n        note: \"\"\n    },\n\n    initialize: function(options) {\n        this.set(\"region\", new GenomeRegion(options.region));\n    }\n});\n\n/**\n * Bookmarks collection.\n */\nvar BrowserBookmarkCollection = Backbone.Collection.extend({\n    model: BrowserBookmark\n});\n\n/**\n * A track of data in a genome visualization.\n */\n// TODO: rename to Track and merge with Trackster's Track object.\nvar BackboneTrack = Backbone.Model.extend(CustomToJSON).extend(\n    {\n        defaults: {\n            mode: \"Auto\"\n        },\n\n        initialize: function(options) {\n            this.set(\"dataset\", new data_mod.Dataset(options.dataset));\n\n            // -- Set up config settings. --\n            var models = [\n                {\n                    key: \"name\",\n                    default_value: this.get(\"dataset\").get(\"name\")\n                },\n                { key: \"color\" },\n                {\n                    key: \"min_value\",\n                    label: \"Min Value\",\n                    type: \"float\",\n                    default_value: 0\n                },\n                {\n                    key: \"max_value\",\n                    label: \"Max Value\",\n                    type: \"float\",\n                    default_value: 1\n                }\n            ];\n\n            this.set(\"config\", config_mod.ConfigSettingCollection.from_models_and_saved_values(models, options.prefs));\n\n            // -- Set up data manager. --\n            var preloaded_data = this.get(\"preloaded_data\");\n            if (preloaded_data) {\n                preloaded_data = preloaded_data.data;\n            } else {\n                preloaded_data = [];\n            }\n            this.set(\n                \"data_manager\",\n                new GenomeDataManager({\n                    dataset: this.get(\"dataset\"),\n                    init_data: preloaded_data\n                })\n            );\n        }\n    },\n    {\n        // This definition matches that produced by to_dict() methods in tracks.js\n        to_json_keys: [\"track_type\", \"dataset\", \"prefs\", \"mode\", \"filters\", \"tool_state\"],\n        to_json_mappers: {\n            prefs: function(p, self) {\n                if (_.size(p) === 0) {\n                    p = {\n                        name: self\n                            .get(\"config\")\n                            .get(\"name\")\n                            .get(\"value\"),\n                        color: self\n                            .get(\"config\")\n                            .get(\"color\")\n                            .get(\"value\")\n                    };\n                }\n                return p;\n            },\n            dataset: function(d) {\n                return {\n                    id: d.id,\n                    hda_ldda: d.get(\"hda_ldda\")\n                };\n            }\n        }\n    }\n);\n\nvar BackboneTrackCollection = Backbone.Collection.extend({\n    model: BackboneTrack\n});\n\n/**\n * A visualization.\n */\nvar Visualization = Backbone.Model.extend({\n    defaults: {\n        title: \"\",\n        type: \"\"\n    },\n\n    urlRoot: `${Galaxy.root}api/visualizations`,\n\n    /**\n     * POSTs visualization's JSON to its URL using the parameter 'vis_json'\n     * Note: This is necessary because (a) Galaxy requires keyword args and\n     * (b) Galaxy does not handle PUT now.\n     */\n    save: function() {\n        return $.ajax({\n            url: this.url(),\n            type: \"POST\",\n            dataType: \"json\",\n            data: {\n                vis_json: JSON.stringify(this)\n            }\n        });\n    }\n});\n\n/**\n * A visualization of genome data.\n */\nvar GenomeVisualization = Visualization.extend(CustomToJSON).extend(\n    {\n        defaults: _.extend({}, Visualization.prototype.defaults, {\n            dbkey: \"\",\n            drawables: null,\n            bookmarks: null,\n            viewport: null\n        }),\n\n        initialize: function(options) {\n            // Replace drawables with tracks.\n            this.set(\"drawables\", new BackboneTrackCollection(options.tracks));\n\n            var models = [];\n            this.set(\"config\", config_mod.ConfigSettingCollection.from_models_and_saved_values(models, options.prefs));\n\n            // Clear track and data definitions to avoid storing large objects.\n            this.unset(\"tracks\");\n            this.get(\"drawables\").each(d => {\n                d.unset(\"preloaded_data\");\n            });\n        },\n\n        /**\n         * Add a track or array of tracks to the visualization.\n         */\n        add_tracks: function(tracks) {\n            this.get(\"drawables\").add(tracks);\n        }\n    },\n    {\n        // This definition matches that produced by to_dict() methods in tracks.js\n        to_json_keys: [\"view\", \"viewport\", \"bookmarks\"],\n\n        to_json_mappers: {\n            view: function(dummy, self) {\n                return {\n                    obj_type: \"View\",\n                    prefs: {\n                        name: self.get(\"title\"),\n                        content_visible: true\n                    },\n                    drawables: self.get(\"drawables\")\n                };\n            }\n        }\n    }\n);\n\n/**\n * -- Routers --\n */\n\n/**\n * Router for track browser.\n */\nvar TrackBrowserRouter = Backbone.Router.extend({\n    initialize: function(options) {\n        this.view = options.view;\n\n        // Can't put regular expression in routes dictionary.\n        // NOTE: parentheses are used to denote parameters returned to callback.\n        this.route(/([\\w]+)$/, \"change_location\");\n        this.route(/([\\w\\+]+\\:[\\d,]+-[\\d,]+)$/, \"change_location\");\n\n        // Handle navigate events from view.\n        var self = this;\n        self.view.on(\"navigate\", new_loc => {\n            self.navigate(new_loc);\n        });\n    },\n\n    change_location: function(new_loc) {\n        this.view.go_to(new_loc);\n    }\n});\n\nexport default {\n    BackboneTrack: BackboneTrack,\n    BrowserBookmark: BrowserBookmark,\n    BrowserBookmarkCollection: BrowserBookmarkCollection,\n    Cache: Cache,\n    CanvasManager: CanvasManager,\n    Genome: Genome,\n    GenomeDataManager: GenomeDataManager,\n    GenomeRegion: GenomeRegion,\n    GenomeRegionCollection: GenomeRegionCollection,\n    GenomeVisualization: GenomeVisualization,\n    GenomeReferenceDataManager: GenomeReferenceDataManager,\n    TrackBrowserRouter: TrackBrowserRouter,\n    Visualization: Visualization,\n    select_datasets: select_datasets\n};\n"]}