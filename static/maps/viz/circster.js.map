{"version":3,"sources":["viz/circster.js"],"names":["_","d3","SVGUtils","Backbone","Model","extend","is_visible","svg_elt","svg","eltBRect","getBoundingClientRect","svgBRect","$","right","left","bottom","top","UsesTicks","drawTicks","parent_elt","data","dataHandler","textTransform","horizontal","ticks","append","selectAll","enter","attr","d","Math","PI","radius","tick_coords","text_coords","text_anchor","angle","style","text","label","formatNum","num","sigDigits","rval","abs","toPrecision","roundedNum","round","toFixed","CircsterLabelTrack","CircsterView","View","className","initialize","options","this","genome","label_arc_height","scale","circular_views","chords_views","model","get","on","add_track","remove_track","update_track_bounds","vis_config","get_circular_tracks","filter","track","get_tracks_bounds","dataset_arc_height","get_value","track_gap","min_dimension","min","$el","width","height","radius_start","circular_tracks","length","tracks_start_radii","map","render","self","chords_tracks","get_chord_tracks","total_gap","select","zoom","translate","tracks_bounds","zoom_drag_timeout","call","index","view","CircsterBigWigTrackView","radius_bounds","el","CircsterChromInteractionsTrackView","outermost_radius","track_bounds","label_track_view","CircsterChromLabelTrackView","new_track","innermost_radius_bounds","new_track_bounds","new_view","track_view","i","each","track_index","update_radius_bounds","tracks","splice","remove","CircsterTrackView","tagName","bg_stroke","bg_fill","chroms_layout","loading_bg_fill","_chroms_layout","data_bounds","get_fill_color","color","track_parent_elt","genome_arcs","arc","innerRadius","outerRadius","chroms_paths","arc_gen","chroms_elts","chrom","data_ready_deferred","data_manager","data_is_ready","when","then","_render_data","render_labels","new_d","_transition_labels","transition","duration","update_scale","_transition_chrom_data","new_scale","old_scale","utils","can_get_more_detailed_data","data_deferred","path_elt","get_chrom_region","_update_data_bounds","chrom_region","get_more_detailed_data","chrom_arc","find","layout","chrom_arcs","chrom_data_paths","num_paths","p_data","get_genome_wide_data","genome_wide_data","reject","chrom_data","path_fn","_get_path_function","new_bounds","path","get_data_bounds","path_data","silent","layout_and_data","rendered_deferred","chrom_info","set_value","zip","_render_chrom_data","chroms_info","pie_layout","resolve","init_arcs","pie","value","len","sort","gap_per_chrom","endAngle","new_endAngle","startAngle","prototype","min_arc_len","chromArcTicks","_update_min_max","c","visibleChroms","k","range","v","track_config","CircsterQuantitativeTrackView","_quantile","numbers","ascending","quantile","datum","linear","domain","clamp","tick","click","ConfigSettingCollectionView","render_in_modal","radial","interpolate","area","line","_data_bounds_ticks_fn","classed","_config2","default","labeledChroms","new_data","flatten","chord_data","values","source","target","target_angle","max","chrom_layout","get_chroms_info","chrom_angle_data","cur_chrom","chrom_chord_data","_get_region_angle","source_angle","GenomeVisualization","add","concat","type","chord","hidden","position","icon_class","vis","add_tracks","Circster","_utils2","cssLoadFile","title","_visualization2","Genome","window","galaxy_config","app","viz_config","body","key","ajax","url","id","dbkey","vis_json","Galaxy","tooltip_config","placement","_iconButton2","create_icon_buttons_menu","tooltip","_localization2","on_click","select_datasets","collection","modal","show","root","dataType","JSON","stringify","success","vis_info","hide","set","vis_id","error","buttons","Cancel","location","menu","GalaxyApp"],"mappings":"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","file":"../../scripts/viz/circster.js","sourcesContent":["import _l from \"utils/localization\";\nimport * as _ from \"libs/underscore\";\nimport * as d3 from \"d3\";\nimport { event as currentEvent } from \"d3\";\nimport visualization from \"viz/visualization\";\nimport mod_utils from \"utils/utils\";\nimport config from \"utils/config\";\nimport mod_icon_btn from \"mvc/ui/icon-button\";\nimport \"libs/farbtastic\";\n/**\n * Utility class for working with SVG.\n */\n\nvar SVGUtils = Backbone.Model.extend({\n    /**\n     * Returns true if element is visible.\n     */\n    is_visible: function(svg_elt, svg) {\n        var eltBRect = svg_elt.getBoundingClientRect();\n        var svgBRect = $(\"svg\")[0].getBoundingClientRect();\n\n        if (\n            // To the left of screen?\n            eltBRect.right < 0 ||\n            // To the right of screen?\n            eltBRect.left > svgBRect.right ||\n            // Above screen?\n            eltBRect.bottom < 0 ||\n            // Below screen?\n            eltBRect.top > svgBRect.bottom\n        ) {\n            return false;\n        }\n        return true;\n    }\n});\n\n/**\n * Mixin for using ticks.\n */\nvar UsesTicks = {\n    drawTicks: function(parent_elt, data, dataHandler, textTransform, horizontal) {\n        // Set up group elements for chroms and for each tick.\n        var ticks = parent_elt\n            .append(\"g\")\n            .selectAll(\"g\")\n            .data(data)\n            .enter()\n            .append(\"g\")\n            .selectAll(\"g\")\n            .data(dataHandler)\n            .enter()\n            .append(\"g\")\n            .attr(\"class\", \"tick\")\n            .attr(\"transform\", d => `rotate(${d.angle * 180 / Math.PI - 90})translate(${d.radius},0)`);\n\n        // Add line + text for ticks.\n        var tick_coords = [];\n\n        var text_coords = [];\n\n        var text_anchor = d => (d.angle > Math.PI ? \"end\" : null);\n\n        if (horizontal) {\n            tick_coords = [0, 0, 0, -4];\n            text_coords = [4, 0, \"\", \".35em\"];\n            text_anchor = null;\n        } else {\n            tick_coords = [1, 0, 4, 0];\n            text_coords = [0, 4, \".35em\", \"\"];\n        }\n\n        ticks\n            .append(\"line\")\n            .attr(\"x1\", tick_coords[0])\n            .attr(\"y1\", tick_coords[1])\n            .attr(\"x2\", tick_coords[2])\n            .attr(\"y1\", tick_coords[3])\n            .style(\"stroke\", \"#000\");\n\n        return ticks\n            .append(\"text\")\n            .attr(\"x\", text_coords[0])\n            .attr(\"y\", text_coords[1])\n            .attr(\"dx\", text_coords[2])\n            .attr(\"dy\", text_coords[3])\n            .attr(\"text-anchor\", text_anchor)\n            .attr(\"transform\", textTransform)\n            .text(d => d.label);\n    },\n\n    /**\n     * Format number for display at a tick.\n     */\n    formatNum: function(num, sigDigits) {\n        // Use default of 2 sig. digits.\n        if (sigDigits === undefined) sigDigits = 2;\n\n        // Verify input number\n        if (num === null) return null;\n\n        // Calculate return value\n        var rval = null;\n        if (Math.abs(num) < 1) {\n            rval = num.toPrecision(sigDigits);\n        } else {\n            // Use round to turn string from toPrecision() back into a number.\n            var roundedNum = Math.round(num.toPrecision(sigDigits));\n\n            // Use abbreviations.\n            num = Math.abs(num);\n            if (num < 1000) {\n                rval = roundedNum;\n            } else if (num < 1000000) {\n                // Use K.\n                rval = `${Math.round((roundedNum / 1000).toPrecision(3)).toFixed(0)}K`;\n            } else if (num < 1000000000) {\n                // Use M.\n                rval = `${Math.round((roundedNum / 1000000).toPrecision(3)).toFixed(0)}M`;\n            }\n        }\n\n        return rval;\n    }\n};\n\n/**\n * A label track.\n */\nvar CircsterLabelTrack = Backbone.Model.extend({});\n\n/**\n * Renders a full circster visualization.\n */\nvar CircsterView = Backbone.View.extend({\n    className: \"circster\",\n\n    initialize: function(options) {\n        this.genome = options.genome;\n        this.label_arc_height = 50;\n        this.scale = 1;\n        this.circular_views = null;\n        this.chords_views = null;\n\n        // When tracks added to/removed from model, update view.\n        this.model.get(\"drawables\").on(\"add\", this.add_track, this);\n        this.model.get(\"drawables\").on(\"remove\", this.remove_track, this);\n\n        // When config settings change, update view.\n        var vis_config = this.model.get(\"config\");\n        vis_config.get(\"arc_dataset_height\").on(\"change:value\", this.update_track_bounds, this);\n        vis_config.get(\"track_gap\").on(\"change:value\", this.update_track_bounds, this);\n    },\n\n    // HACKs: using track_type for circular/chord distinction in the functions below for now.\n\n    /**\n     * Returns tracks to be rendered using circular view.\n     */\n    get_circular_tracks: function() {\n        return this.model.get(\"drawables\").filter(track => track.get(\"track_type\") !== \"DiagonalHeatmapTrack\");\n    },\n\n    /**\n     * Returns tracks to be rendered using chords view.\n     */\n    get_chord_tracks: function() {\n        return this.model.get(\"drawables\").filter(track => track.get(\"track_type\") === \"DiagonalHeatmapTrack\");\n    },\n\n    /**\n     * Returns a list of circular tracks' radius bounds.\n     */\n    get_tracks_bounds: function() {\n        var circular_tracks = this.get_circular_tracks();\n\n        var dataset_arc_height = this.model.get(\"config\").get_value(\"arc_dataset_height\");\n\n        var track_gap = this.model.get(\"config\").get_value(\"track_gap\");\n\n        var // Subtract 20 to make sure chrom labels are on screen.\n        min_dimension = Math.min(this.$el.width(), this.$el.height()) - 20;\n\n        var // Compute radius start based on model, will be centered\n        // and fit entirely inside element by default.\n        radius_start =\n            min_dimension / 2 -\n            circular_tracks.length * (dataset_arc_height + track_gap) +\n            // Add track_gap back in because no gap is needed for last track.\n            track_gap -\n            this.label_arc_height;\n\n        var // Compute range of track starting radii.\n        tracks_start_radii = d3.range(radius_start, min_dimension / 2, dataset_arc_height + track_gap);\n\n        // Map from track start to bounds.\n        return _.map(tracks_start_radii, radius => [radius, radius + dataset_arc_height]);\n    },\n\n    /**\n     * Renders circular tracks, chord tracks, and label tracks.\n     */\n    render: function() {\n        var self = this;\n        var width = self.$el.width();\n        var height = self.$el.height();\n        var circular_tracks = this.get_circular_tracks();\n        var chords_tracks = this.get_chord_tracks();\n        var total_gap = self.model.get(\"config\").get_value(\"total_gap\");\n        var tracks_bounds = this.get_tracks_bounds();\n\n        var // Set up SVG element.\n        svg = d3\n            .select(self.$el[0])\n            .append(\"svg\")\n            .attr(\"width\", width)\n            .attr(\"height\", height)\n            .attr(\"pointer-events\", \"all\")\n            // Set up zooming, dragging.\n            .append(\"svg:g\")\n            .call(\n                d3.behavior.zoom().on(\"zoom\", () => {\n                    // Do zoom, drag.\n                    var scale = currentEvent.scale;\n                    svg.attr(\"transform\", `translate(${currentEvent.translate}) scale(${scale})`);\n\n                    // Propagate scale changes to views.\n                    if (self.scale !== scale) {\n                        // Use timeout to wait for zooming/dragging to stop before rendering more detail.\n                        if (self.zoom_drag_timeout) {\n                            clearTimeout(self.zoom_drag_timeout);\n                        }\n                        self.zoom_drag_timeout = setTimeout(() => {\n                            // Render more detail in tracks' visible elements.\n                            // FIXME: do not do this right now; it is not fully implemented--e.g. data bounds\n                            // are not updated when new data is fetched--and fetching more detailed quantitative\n                            // data is not that useful.\n                            /*\n                        _.each(self.circular_views, function(view) {\n                            view.update_scale(scale);\n                        });\n                        */\n                        }, 400);\n                    }\n                })\n            )\n            .attr(\"transform\", `translate(${width / 2},${height / 2})`)\n            .append(\"svg:g\")\n            .attr(\"class\", \"tracks\");\n\n        // -- Render circular tracks. --\n\n        // Create a view for each track in the visualization and render.\n        this.circular_views = circular_tracks.map((track, index) => {\n            var view = new CircsterBigWigTrackView({\n                el: svg.append(\"g\")[0],\n                track: track,\n                radius_bounds: tracks_bounds[index],\n                genome: self.genome,\n                total_gap: total_gap\n            });\n\n            view.render();\n\n            return view;\n        });\n\n        // -- Render chords tracks. --\n\n        this.chords_views = chords_tracks.map(track => {\n            var view = new CircsterChromInteractionsTrackView({\n                el: svg.append(\"g\")[0],\n                track: track,\n                radius_bounds: tracks_bounds[0],\n                genome: self.genome,\n                total_gap: total_gap\n            });\n\n            view.render();\n\n            return view;\n        });\n\n        // -- Render label track. --\n\n        // Track bounds are:\n        // (a) outer radius of last circular track;\n        // (b)\n        var outermost_radius = this.circular_views[this.circular_views.length - 1].radius_bounds[1];\n\n        var track_bounds = [outermost_radius, outermost_radius + this.label_arc_height];\n\n        this.label_track_view = new CircsterChromLabelTrackView({\n            el: svg.append(\"g\")[0],\n            track: new CircsterLabelTrack(),\n            radius_bounds: track_bounds,\n            genome: self.genome,\n            total_gap: total_gap\n        });\n\n        this.label_track_view.render();\n    },\n\n    /**\n     * Render a single track on the outside of the current visualization.\n     */\n    add_track: function(new_track) {\n        var total_gap = this.model.get(\"config\").get_value(\"total_gap\");\n\n        if (new_track.get(\"track_type\") === \"DiagonalHeatmapTrack\") {\n            // Added chords track.\n            var innermost_radius_bounds = this.circular_views[0].radius_bounds;\n\n            var new_view = new CircsterChromInteractionsTrackView({\n                el: d3.select(\"g.tracks\").append(\"g\")[0],\n                track: new_track,\n                radius_bounds: innermost_radius_bounds,\n                genome: this.genome,\n                total_gap: total_gap\n            });\n\n            new_view.render();\n            this.chords_views.push(new_view);\n        } else {\n            // Added circular track.\n\n            // Recompute and update circular track bounds.\n            var new_track_bounds = this.get_tracks_bounds();\n            _.each(this.circular_views, (track_view, i) => {\n                track_view.update_radius_bounds(new_track_bounds[i]);\n            });\n\n            // Update chords tracks.\n            _.each(this.chords_views, track_view => {\n                track_view.update_radius_bounds(new_track_bounds[0]);\n            });\n\n            // Render new track.\n            var track_index = this.circular_views.length;\n\n            var track_view = new CircsterBigWigTrackView({\n                el: d3.select(\"g.tracks\").append(\"g\")[0],\n                track: new_track,\n                radius_bounds: new_track_bounds[track_index],\n                genome: this.genome,\n                total_gap: total_gap\n            });\n\n            track_view.render();\n            this.circular_views.push(track_view);\n\n            // Update label track.\n            /*\n            FIXME: should never have to update label track because vis always expands to fit area\n            within label track.\n            var track_bounds = new_track_bounds[ new_track_bounds.length-1 ];\n            track_bounds[1] = track_bounds[0];\n            this.label_track_view.update_radius_bounds(track_bounds);\n            */\n        }\n    },\n\n    /**\n     * Remove a track from the view.\n     */\n    remove_track: function(track, tracks, options) {\n        // -- Remove track from view. --\n        var track_view = this.circular_views[options.index];\n        this.circular_views.splice(options.index, 1);\n        track_view.$el.remove();\n\n        // Recompute and update track bounds.\n        var new_track_bounds = this.get_tracks_bounds();\n        _.each(this.circular_views, (track_view, i) => {\n            track_view.update_radius_bounds(new_track_bounds[i]);\n        });\n    },\n\n    update_track_bounds: function() {\n        // Recompute and update track bounds.\n        var new_track_bounds = this.get_tracks_bounds();\n        _.each(this.circular_views, (track_view, i) => {\n            track_view.update_radius_bounds(new_track_bounds[i]);\n        });\n\n        // Update chords tracks.\n        _.each(this.chords_views, track_view => {\n            track_view.update_radius_bounds(new_track_bounds[0]);\n        });\n    }\n});\n\n/**\n * Renders a track in a Circster visualization.\n */\nvar CircsterTrackView = Backbone.View.extend({\n    tagName: \"g\",\n\n    /* ----------------------- Public Methods ------------------------- */\n\n    initialize: function(options) {\n        this.bg_stroke = \"#ddd\";\n        // Fill color when loading data.\n        this.loading_bg_fill = \"#ffc\";\n        // Fill color when data has been loaded.\n        this.bg_fill = \"#ddd\";\n        this.total_gap = options.total_gap;\n        this.track = options.track;\n        this.radius_bounds = options.radius_bounds;\n        this.genome = options.genome;\n        this.chroms_layout = this._chroms_layout();\n        this.data_bounds = [];\n        this.scale = 1;\n        this.parent_elt = d3.select(this.$el[0]);\n    },\n\n    /**\n     * Get fill color from config.\n     */\n    get_fill_color: function() {\n        var color = this.track.get(\"config\").get_value(\"block_color\");\n        if (!color) {\n            color = this.track.get(\"config\").get_value(\"color\");\n        }\n        return color;\n    },\n\n    /**\n     * Render track's data by adding SVG elements to parent.\n     */\n    render: function() {\n        // -- Create track group element. --\n        var track_parent_elt = this.parent_elt;\n\n        // -- Render background arcs. --\n        var genome_arcs = this.chroms_layout;\n\n        var arc_gen = d3.svg\n            .arc()\n            .innerRadius(this.radius_bounds[0])\n            .outerRadius(this.radius_bounds[1]);\n\n        var // Attach data to group element.\n        chroms_elts = track_parent_elt\n            .selectAll(\"g\")\n            .data(genome_arcs)\n            .enter()\n            .append(\"svg:g\");\n\n        var // Draw chrom arcs/paths.\n        chroms_paths = chroms_elts\n            .append(\"path\")\n            .attr(\"d\", arc_gen)\n            .attr(\"class\", \"chrom-background\")\n            .style(\"stroke\", this.bg_stroke)\n            .style(\"fill\", this.loading_bg_fill);\n\n        // Append titles to paths.\n        chroms_paths.append(\"title\").text(d => d.data.chrom);\n\n        // -- Render track data and, when track data is rendered, apply preferences and update chrom_elts fill. --\n\n        var self = this;\n\n        var data_manager = self.track.get(\"data_manager\");\n\n        var // If track has a data manager, get deferred that resolves when data is ready.\n        data_ready_deferred = data_manager ? data_manager.data_is_ready() : true;\n\n        // When data is ready, render track.\n        $.when(data_ready_deferred).then(() => {\n            $.when(self._render_data(track_parent_elt)).then(() => {\n                chroms_paths.style(\"fill\", self.bg_fill);\n\n                // Render labels after data is available so that data attributes are available.\n                self.render_labels();\n            });\n        });\n    },\n\n    /**\n     * Render track labels.\n     */\n    render_labels: function() {},\n\n    /**\n     * Update radius bounds.\n     */\n    update_radius_bounds: function(radius_bounds) {\n        // Update bounds.\n        this.radius_bounds = radius_bounds;\n\n        // -- Update background arcs. --\n        var new_d = d3.svg\n            .arc()\n            .innerRadius(this.radius_bounds[0])\n            .outerRadius(this.radius_bounds[1]);\n\n        this.parent_elt\n            .selectAll(\"g>path.chrom-background\")\n            .transition()\n            .duration(1000)\n            .attr(\"d\", new_d);\n\n        this._transition_chrom_data();\n\n        this._transition_labels();\n    },\n\n    /**\n     * Update view scale. This fetches more data if scale is increased.\n     */\n    update_scale: function(new_scale) {\n        // -- Update scale and return if new scale is less than old scale. --\n\n        var old_scale = this.scale;\n        this.scale = new_scale;\n        if (new_scale <= old_scale) {\n            return;\n        }\n\n        // -- Scale increased, so render visible data with more detail. --\n\n        var self = this;\n\n        var utils = new SVGUtils();\n\n        // Select all chrom data and filter to operate on those that are visible.\n        this.parent_elt\n            .selectAll(\"path.chrom-data\")\n            .filter(function(d, i) {\n                return utils.is_visible(this);\n            })\n            .each(function(d, i) {\n                // -- Now operating on a single path element representing chromosome data. --\n\n                var path_elt = d3.select(this);\n\n                var chrom = path_elt.attr(\"chrom\");\n                var chrom_region = self.genome.get_chrom_region(chrom);\n                var data_manager = self.track.get(\"data_manager\");\n                var data_deferred;\n\n                // If can't get more detailed data, return.\n                if (!data_manager.can_get_more_detailed_data(chrom_region)) {\n                    return;\n                }\n\n                // -- Get more detailed data. --\n                data_deferred = self.track\n                    .get(\"data_manager\")\n                    .get_more_detailed_data(chrom_region, \"Coverage\", 0, new_scale);\n\n                // When more data is available, use new data to redraw path.\n                $.when(data_deferred).then(data => {\n                    // Remove current data path.\n                    path_elt.remove();\n\n                    // Update data bounds with new data.\n                    self._update_data_bounds();\n\n                    // Find chromosome arc to draw data on.\n                    var chrom_arc = _.find(self.chroms_layout, layout => layout.data.chrom === chrom);\n\n                    // Add new data path and apply preferences.\n                    var color = self.get_fill_color();\n                    self\n                        ._render_chrom_data(self.parent_elt, chrom_arc, data)\n                        .style(\"stroke\", color)\n                        .style(\"fill\", color);\n                });\n            });\n\n        return self;\n    },\n\n    /* ----------------------- Internal Methods ------------------------- */\n\n    /**\n     * Transitions chrom data to new values (e.g new radius or data bounds).\n     */\n    _transition_chrom_data: function() {\n        var track = this.track;\n        var chrom_arcs = this.chroms_layout;\n        var chrom_data_paths = this.parent_elt.selectAll(\"g>path.chrom-data\");\n        var num_paths = chrom_data_paths[0].length;\n\n        if (num_paths > 0) {\n            var self = this;\n            $.when(track.get(\"data_manager\").get_genome_wide_data(this.genome)).then(genome_wide_data => {\n                // Map chrom data to path data, filtering out null values.\n                var path_data = _.reject(\n                    _.map(genome_wide_data, (chrom_data, i) => {\n                        var rval = null;\n\n                        var path_fn = self._get_path_function(chrom_arcs[i], chrom_data);\n\n                        if (path_fn) {\n                            rval = path_fn(chrom_data.data);\n                        }\n                        return rval;\n                    }),\n                    p_data => p_data === null\n                );\n\n                // Transition each path for data and color.\n                var color = track.get(\"config\").get_value(\"color\");\n                chrom_data_paths.each(function(path, index) {\n                    d3\n                        .select(this)\n                        .transition()\n                        .duration(1000)\n                        .style(\"stroke\", color)\n                        .style(\"fill\", color)\n                        .attr(\"d\", path_data[index]);\n                });\n            });\n        }\n    },\n\n    /**\n     * Transition labels to new values (e.g new radius or data bounds).\n     */\n    _transition_labels: function() {},\n\n    /**\n     * Update data bounds. If there are new_bounds, use them; otherwise use\n     * default data bounds.\n     */\n    _update_data_bounds: function(new_bounds) {\n        this.data_bounds =\n            new_bounds || this.get_data_bounds(this.track.get(\"data_manager\").get_genome_wide_data(this.genome));\n        this._transition_chrom_data();\n    },\n\n    /**\n     * Render data as elements attached to svg.\n     */\n    _render_data: function(svg) {\n        var self = this;\n        var chrom_arcs = this.chroms_layout;\n        var track = this.track;\n        var rendered_deferred = $.Deferred();\n\n        // When genome-wide data is available, render data.\n        $.when(track.get(\"data_manager\").get_genome_wide_data(this.genome)).then(genome_wide_data => {\n            // Set bounds.\n            self.data_bounds = self.get_data_bounds(genome_wide_data);\n\n            // Set min, max value in config so that they can be adjusted. Make this silent\n            // because these attributes are watched for changes and the viz is updated\n            // accordingly (set up in initialize). Because we are setting up, we don't want\n            // the watch to trigger events here.\n            track.get(\"config\").set_value(\"min_value\", self.data_bounds[0], {\n                silent: true\n            });\n            track.get(\"config\").set_value(\"max_value\", self.data_bounds[1], {\n                silent: true\n            });\n\n            // Merge chroms layout with data.\n            var layout_and_data = _.zip(chrom_arcs, genome_wide_data);\n\n            // Render each chromosome's data.\n            _.each(layout_and_data, chrom_info => {\n                var chrom_arc = chrom_info[0];\n                var data = chrom_info[1];\n                return self._render_chrom_data(svg, chrom_arc, data);\n            });\n\n            // Apply prefs to all track data.\n            var color = self.get_fill_color();\n            self.parent_elt\n                .selectAll(\"path.chrom-data\")\n                .style(\"stroke\", color)\n                .style(\"fill\", color);\n\n            rendered_deferred.resolve(svg);\n        });\n\n        return rendered_deferred;\n    },\n\n    /**\n     * Render a chromosome data and attach elements to svg.\n     */\n    _render_chrom_data: function(svg, chrom_arc, data) {},\n\n    /**\n     * Returns data for creating a path for the given data using chrom_arc and data bounds.\n     */\n    _get_path_function: function(chrom_arc, chrom_data) {},\n\n    /**\n     * Returns arc layouts for genome's chromosomes/contigs. Arcs are arranged in a circle\n     * separated by gaps.\n     */\n    _chroms_layout: function() {\n        // Setup chroms layout using pie.\n        var chroms_info = this.genome.get_chroms_info();\n\n        var pie_layout = d3.layout\n            .pie()\n            .value(d => d.len)\n            .sort(null);\n\n        var init_arcs = pie_layout(chroms_info);\n        var gap_per_chrom = 2 * Math.PI * this.total_gap / chroms_info.length;\n\n        var chrom_arcs = _.map(init_arcs, (arc, index) => {\n            // For short chroms, endAngle === startAngle.\n            var new_endAngle = arc.endAngle - gap_per_chrom;\n            arc.endAngle = new_endAngle > arc.startAngle ? new_endAngle : arc.startAngle;\n            return arc;\n        });\n\n        return chrom_arcs;\n    }\n});\n\n/**\n * Render chromosome labels.\n */\nvar CircsterChromLabelTrackView = CircsterTrackView.extend({\n    initialize: function(options) {\n        CircsterTrackView.prototype.initialize.call(this, options);\n        // Use a single arc for rendering data.\n        this.innerRadius = this.radius_bounds[0];\n        this.radius_bounds[0] = this.radius_bounds[1];\n        this.bg_stroke = \"#fff\";\n        this.bg_fill = \"#fff\";\n\n        // Minimum arc distance for labels to be applied.\n        this.min_arc_len = 0.05;\n    },\n\n    /**\n     * Render labels.\n     */\n    _render_data: function(svg) {\n        // -- Add chromosome label where it will fit; an alternative labeling mechanism\n        // would be nice for small chromosomes. --\n        var self = this;\n\n        var chrom_arcs = svg.selectAll(\"g\");\n\n        chrom_arcs.selectAll(\"path\").attr(\"id\", d => `label-${d.data.chrom}`);\n\n        chrom_arcs\n            .append(\"svg:text\")\n            .filter(d => d.endAngle - d.startAngle > self.min_arc_len)\n            .attr(\"text-anchor\", \"middle\")\n            .append(\"svg:textPath\")\n            .attr(\"class\", \"chrom-label\")\n            .attr(\"xlink:href\", d => `#label-${d.data.chrom}`)\n            .attr(\"startOffset\", \"25%\")\n            .text(d => d.data.chrom);\n\n        // -- Add ticks to denote chromosome length. --\n\n        /** Returns an array of tick angles and labels, given a chrom arc. */\n        var chromArcTicks = d => {\n            var k = (d.endAngle - d.startAngle) / d.value;\n\n            var ticks = d3.range(0, d.value, 25000000).map((v, i) => ({\n                radius: self.innerRadius,\n                angle: v * k + d.startAngle,\n                label: i === 0 ? 0 : i % 3 ? null : self.formatNum(v)\n            }));\n\n            // If there are fewer that 4 ticks, label last tick so that at least one non-zero tick is labeled.\n            if (ticks.length < 4) {\n                ticks[ticks.length - 1].label = self.formatNum(\n                    Math.round((ticks[ticks.length - 1].angle - d.startAngle) / k)\n                );\n            }\n\n            return ticks;\n        };\n\n        /** Rotate and move text as needed. */\n        var textTransform = d => (d.angle > Math.PI ? \"rotate(180)translate(-16)\" : null);\n\n        // Filter chroms for only those large enough for display.\n        var visibleChroms = _.filter(this.chroms_layout, c => c.endAngle - c.startAngle > self.min_arc_len);\n\n        this.drawTicks(this.parent_elt, visibleChroms, chromArcTicks, textTransform);\n    }\n});\n_.extend(CircsterChromLabelTrackView.prototype, UsesTicks);\n\n/**\n * View for quantitative track in Circster.\n */\nvar CircsterQuantitativeTrackView = CircsterTrackView.extend({\n    initialize: function(options) {\n        CircsterTrackView.prototype.initialize.call(this, options);\n\n        // When config settings change, update view.\n        var track_config = this.track.get(\"config\");\n        track_config.get(\"min_value\").on(\"change:value\", this._update_min_max, this);\n        track_config.get(\"max_value\").on(\"change:value\", this._update_min_max, this);\n        track_config.get(\"color\").on(\"change:value\", this._transition_chrom_data, this);\n    },\n\n    /**\n     * Update track when min and/or max are changed.\n     */\n    _update_min_max: function() {\n        var track_config = this.track.get(\"config\");\n\n        var new_bounds = [track_config.get_value(\"min_value\"), track_config.get_value(\"max_value\")];\n\n        this._update_data_bounds(new_bounds);\n\n        // FIXME: this works to update tick/text bounds, but there's probably a better way to do this\n        // by updating the data itself.\n        this.parent_elt.selectAll(\".min_max\").text((d, i) => new_bounds[i]);\n    },\n\n    /**\n     * Returns quantile for an array of numbers.\n     */\n    _quantile: function(numbers, quantile) {\n        numbers.sort(d3.ascending);\n        return d3.quantile(numbers, quantile);\n    },\n\n    /**\n     * Renders quantitative data with the form [x, value] and assumes data is equally spaced across\n     * chromosome. Attachs a dict with track and chrom name information to DOM element.\n     */\n    _render_chrom_data: function(svg, chrom_arc, chrom_data) {\n        var path_data = this._get_path_function(chrom_arc, chrom_data);\n\n        if (!path_data) {\n            return null;\n        }\n\n        // There is path data, so render as path.\n        var parent = svg.datum(chrom_data.data);\n\n        var path = parent\n            .append(\"path\")\n            .attr(\"class\", \"chrom-data\")\n            .attr(\"chrom\", chrom_arc.data.chrom)\n            .attr(\"d\", path_data);\n\n        return path;\n    },\n\n    /**\n     * Returns function for creating a path across the chrom arc.\n     */\n    _get_path_function: function(chrom_arc, chrom_data) {\n        // If no chrom data, return null.\n        if (typeof chrom_data === \"string\" || !chrom_data.data || chrom_data.data.length === 0) {\n            return null;\n        }\n\n        // Radius scaler.\n        var radius = d3.scale\n            .linear()\n            .domain(this.data_bounds)\n            .range(this.radius_bounds)\n            .clamp(true);\n\n        // Scaler for placing data points across arc.\n        var angle = d3.scale\n            .linear()\n            .domain([0, chrom_data.data.length])\n            .range([chrom_arc.startAngle, chrom_arc.endAngle]);\n\n        // Use line generator to create area.\n        var line = d3.svg.line\n            .radial()\n            .interpolate(\"linear\")\n            .radius(d => radius(d[1]))\n            .angle((d, i) => angle(i));\n\n        return d3.svg.area\n            .radial()\n            .interpolate(line.interpolate())\n            .innerRadius(radius(0))\n            .outerRadius(line.radius())\n            .angle(line.angle());\n    },\n\n    /**\n     * Render track min, max using ticks.\n     */\n    render_labels: function() {\n        var self = this;\n\n        var // Keep counter of visible chroms.\n        textTransform = () => \"rotate(90)\";\n\n        // FIXME:\n        // (1) using min_max class below is needed for _update_min_max, which could be improved.\n        // (2) showing config on tick click should be replaced by proper track config icon.\n\n        // Draw min, max on first chrom only.\n        var ticks = this.drawTicks(\n            this.parent_elt,\n            [this.chroms_layout[0]],\n            this._data_bounds_ticks_fn(),\n            textTransform,\n            true\n        ).classed(\"min_max\", true);\n\n        // Show config when ticks are clicked on.\n        _.each(ticks, tick => {\n            $(tick).click(() => {\n                var view = new config.ConfigSettingCollectionView({\n                    collection: self.track.get(\"config\")\n                });\n                view.render_in_modal(\"Configure Track\");\n            });\n        });\n\n        /*\n        // Filter for visible chroms, then for every third chrom so that labels attached to only every\n        // third chrom.\n        var visibleChroms = _.filter(this.chroms_layout, function(c) { return c.endAngle - c.startAngle > 0.08; }),\n            labeledChroms = _.filter(visibleChroms, function(c, i) { return i % 3 === 0; });\n        this.drawTicks(this.parent_elt, labeledChroms, this._data_bounds_ticks_fn(), textTransform, true);\n        */\n    },\n\n    /**\n     * Transition labels to new values (e.g new radius or data bounds).\n     */\n    _transition_labels: function() {\n        // FIXME: (a) pull out function for getting labeled chroms? and (b) function used in transition below\n        // is copied from UseTicks mixin, so pull out and make generally available.\n\n        // If there are no data bounds, nothing to transition.\n        if (this.data_bounds.length === 0) {\n            return;\n        }\n\n        // Transition labels to new radius bounds.\n        var self = this;\n\n        var visibleChroms = _.filter(this.chroms_layout, c => c.endAngle - c.startAngle > 0.08);\n\n        var labeledChroms = _.filter(visibleChroms, (c, i) => i % 3 === 0);\n\n        var new_data = _.flatten(_.map(labeledChroms, c => self._data_bounds_ticks_fn()(c)));\n\n        this.parent_elt\n            .selectAll(\"g.tick\")\n            .data(new_data)\n            .transition()\n            .attr(\"transform\", d => `rotate(${d.angle * 180 / Math.PI - 90})translate(${d.radius},0)`);\n    },\n\n    /**\n     * Get function for locating data bounds ticks.\n     */\n    _data_bounds_ticks_fn: function() {\n        // Closure vars.\n        var self = this;\n\n        // Return function for locating ticks based on chrom arc data.\n        return (\n            d // Set up data to display min, max ticks.\n        ) => [\n            {\n                radius: self.radius_bounds[0],\n                angle: d.startAngle,\n                label: self.formatNum(self.data_bounds[0])\n            },\n            {\n                radius: self.radius_bounds[1],\n                angle: d.startAngle,\n                label: self.formatNum(self.data_bounds[1])\n            }\n        ];\n    },\n\n    /**\n     * Returns an array with two values denoting the minimum and maximum\n     * values for the track.\n     */\n    get_data_bounds: function(data) {}\n});\n_.extend(CircsterQuantitativeTrackView.prototype, UsesTicks);\n\n/**\n * Bigwig track view in Circster.\n */\nvar CircsterBigWigTrackView = CircsterQuantitativeTrackView.extend({\n    get_data_bounds: function(data) {\n        // Set max across dataset by extracting all values, flattening them into a\n        // single array, and getting third quartile.\n        var values = _.flatten(\n            _.map(data, d => {\n                if (d) {\n                    // Each data point has the form [position, value], so return all values.\n                    return _.map(\n                        d.data,\n                        (\n                            p // Null is used for a lack of data; resolve null to 0 for comparison.\n                        ) => parseInt(p[1], 10) || 0\n                    );\n                } else {\n                    return 0;\n                }\n            })\n        );\n\n        // For max, use 98% quantile in attempt to avoid very large values. However, this max may be 0\n        // for sparsely populated data, so use max in that case.\n        return [_.min(values), this._quantile(values, 0.98) || _.max(values)];\n    }\n});\n\n/**\n * Chromosome interactions track view in Circster.\n */\nvar CircsterChromInteractionsTrackView = CircsterTrackView.extend({\n    render: function() {\n        var self = this;\n\n        // When data is ready, render track.\n        $.when(self.track.get(\"data_manager\").data_is_ready()).then(() => {\n            // When data has been fetched, render track.\n            $.when(self.track.get(\"data_manager\").get_genome_wide_data(self.genome)).then(genome_wide_data => {\n                var chord_data = [];\n                var chroms_info = self.genome.get_chroms_info();\n                // Convert chromosome data into chord data.\n                _.each(genome_wide_data, (chrom_data, index) => {\n                    // Map each interaction into chord data.\n                    var cur_chrom = chroms_info[index].chrom;\n                    var chrom_chord_data = _.map(chrom_data.data, datum => {\n                        // Each datum is an interaction/chord.\n                        var source_angle = self._get_region_angle(cur_chrom, datum[1]);\n\n                        var target_angle = self._get_region_angle(datum[3], datum[4]);\n\n                        return {\n                            source: {\n                                startAngle: source_angle,\n                                endAngle: source_angle + 0.01\n                            },\n                            target: {\n                                startAngle: target_angle,\n                                endAngle: target_angle + 0.01\n                            }\n                        };\n                    });\n\n                    chord_data = chord_data.concat(chrom_chord_data);\n                });\n\n                self.parent_elt\n                    .append(\"g\")\n                    .attr(\"class\", \"chord\")\n                    .selectAll(\"path\")\n                    .data(chord_data)\n                    .enter()\n                    .append(\"path\")\n                    .style(\"fill\", self.get_fill_color())\n                    .attr(\"d\", d3.svg.chord().radius(self.radius_bounds[0]))\n                    .style(\"opacity\", 1);\n            });\n        });\n    },\n\n    update_radius_bounds: function(radius_bounds) {\n        this.radius_bounds = radius_bounds;\n        this.parent_elt\n            .selectAll(\"path\")\n            .transition()\n            .attr(\"d\", d3.svg.chord().radius(this.radius_bounds[0]));\n    },\n\n    /**\n     * Returns radians for a genomic position.\n     */\n    _get_region_angle: function(chrom, position) {\n        // Find chrom angle data\n        var chrom_angle_data = _.find(this.chroms_layout, chrom_layout => chrom_layout.data.chrom === chrom);\n\n        // Return angle at position.\n        return (\n            chrom_angle_data.endAngle -\n            (chrom_angle_data.endAngle - chrom_angle_data.startAngle) *\n                (chrom_angle_data.data.len - position) /\n                chrom_angle_data.data.len\n        );\n    }\n});\n\n// circster app loader\nvar Circster = Backbone.View.extend({\n    initialize: function() {\n        // load css\n        mod_utils.cssLoadFile(\"static/style/circster.css\");\n        // -- Configure visualization --\n        var genome = new visualization.Genome(window.galaxy_config.app.genome);\n\n        var vis = new visualization.GenomeVisualization(window.galaxy_config.app.viz_config);\n\n        // Add Circster-specific config options.\n        vis.get(\"config\").add([\n            {\n                key: \"arc_dataset_height\",\n                label: \"Arc Dataset Height\",\n                type: \"int\",\n                value: 25,\n                view: \"circster\"\n            },\n            {\n                key: \"track_gap\",\n                label: \"Gap Between Tracks\",\n                type: \"int\",\n                value: 5,\n                view: \"circster\"\n            },\n            {\n                key: \"total_gap\",\n                label: \"Gap [0-1]\",\n                type: \"float\",\n                value: 0.4,\n                view: \"circster\",\n                hidden: true\n            }\n        ]);\n\n        var viz_view = new CircsterView({\n            // view pane\n            el: $(\"#center .unified-panel-body\"),\n            genome: genome,\n            model: vis\n        });\n\n        // Render vizualization\n        viz_view.render();\n\n        // setup title\n        $(\"#center .unified-panel-header-inner\").append(\n            `${window.galaxy_config.app.viz_config.title} ${window.galaxy_config.app.viz_config.dbkey}`\n        );\n\n        // setup menu\n        var menu = mod_icon_btn.create_icon_buttons_menu(\n            [\n                {\n                    icon_class: \"plus-button\",\n                    title: _l(\"Add tracks\"),\n                    on_click: function() {\n                        visualization.select_datasets({ dbkey: vis.get(\"dbkey\") }, tracks => {\n                            vis.add_tracks(tracks);\n                        });\n                    }\n                },\n                {\n                    icon_class: \"gear\",\n                    title: _l(\"Settings\"),\n                    on_click: function() {\n                        var view = new config.ConfigSettingCollectionView({\n                            collection: vis.get(\"config\")\n                        });\n                        view.render_in_modal(\"Configure Visualization\");\n                    }\n                },\n                {\n                    icon_class: \"disk--arrow\",\n                    title: _l(\"Save\"),\n                    on_click: function() {\n                        // show saving dialog box\n                        Galaxy.modal.show({\n                            title: _l(\"Saving...\"),\n                            body: \"progress\"\n                        });\n\n                        // send to server\n                        $.ajax({\n                            url: `${Galaxy.root}visualization/save`,\n                            type: \"POST\",\n                            dataType: \"json\",\n                            data: {\n                                id: vis.get(\"vis_id\"),\n                                title: vis.get(\"title\"),\n                                dbkey: vis.get(\"dbkey\"),\n                                type: \"trackster\",\n                                vis_json: JSON.stringify(vis)\n                            }\n                        })\n                            .success(vis_info => {\n                                Galaxy.modal.hide();\n                                vis.set(\"vis_id\", vis_info.vis_id);\n                            })\n                            .error(() => {\n                                // show dialog\n                                Galaxy.modal.show({\n                                    title: _l(\"Could Not Save\"),\n                                    body: \"Could not save visualization. Please try again later.\",\n                                    buttons: {\n                                        Cancel: function() {\n                                            Galaxy.modal.hide();\n                                        }\n                                    }\n                                });\n                            });\n                    }\n                },\n                {\n                    icon_class: \"cross-circle\",\n                    title: _l(\"Close\"),\n                    on_click: function() {\n                        window.location = `${Galaxy.root}visualizations/list`;\n                    }\n                }\n            ],\n            { tooltip_config: { placement: \"bottom\" } }\n        );\n\n        // add menu\n        menu.$el.attr(\"style\", \"float: right\");\n        $(\"#center .unified-panel-header-inner\").append(menu.$el);\n\n        // manual tooltip config because default gravity is S and cannot be changed\n        $(\".menu-button\").tooltip({ placement: \"bottom\" });\n    }\n});\n\n// Module exports.\nexport default {\n    GalaxyApp: Circster\n};\n"]}